<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PRD_Equipment_Dependency_Validation_v1.0</title>

<style>
body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
    font-size: 16px;
    line-height: 1.5;
    word-wrap: break-word;
    color: #24292e;
    background-color: #fff;
    max-width: 900px;
    margin: 0 auto;
    padding: 2rem;
}
h1, h2, h3, h4, h5, h6 {
    margin-top: 24px;
    margin-bottom: 16px;
    font-weight: 600;
    line-height: 1.25;
}
h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
h3 { font-size: 1.25em; }
code {
    padding: 0.2em 0.4em;
    margin: 0;
    font-size: 85%;
    background-color: #f6f8fa;
    border-radius: 6px;
    font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
}
pre {
    padding: 16px;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f6f8fa;
    border-radius: 6px;
}
pre code {
    display: inline;
    padding: 0;
    margin: 0;
    overflow: visible;
    line-height: inherit;
    word-wrap: normal;
    background-color: initial;
    border: 0;
}
blockquote {
    padding: 0 1em;
    color: #6a737d;
    border-left: 0.25em solid #dfe2e5;
    margin: 0;
}
table {
    display: block;
    width: 100%;
    margin-top: 0;
    margin-bottom: 16px;
    overflow: auto;
    border-spacing: 0;
    border-collapse: collapse;
}
table th, table td {
    padding: 6px 13px;
    border: 1px solid #dfe2e5;
}
table tr {
    background-color: #fff;
    border-top: 1px solid #c6cbd1;
}
table tr:nth-child(2n) {
    background-color: #f6f8fa;
}
a { color: #0366d6; text-decoration: none; }
a:hover { text-decoration: underline; }
hr {
    height: 0.25em;
    padding: 0;
    margin: 24px 0;
    background-color: #e1e4e8;
    border: 0;
}
</style>

</head>
<body>
<h1 id="prd-v10-equipment-dependency-validation">PRD v1.0: 設備依賴關係驗證規範 (Equipment Dependency Validation)</h1>
<h1 id="etl">ETL階段物理邏輯一致性檢查與歷史資料驗證</h1>
<p><strong>文件版本:</strong> v1.0 (ETL-Stage Physical Logic Validation)<br />
<strong>日期:</strong> 2026-02-13<br />
<strong>負責人:</strong> Oscar Chang<br />
<strong>目標模組:</strong> <code>src/etl/equipment_validator.py</code>, <code>src/etl/cleaner.py</code> (擴充), <code>src/etl/batch_processor.py</code> (擴充)<br />
<strong>上游契約:</strong> <code>src/optimization/constraints.py</code> (Logic Constraints 定義)<br />
<strong>下游契約:</strong> <code>src/etl/feature_engineer.py</code> (v1.3+, 檢查點 #3)<br />
<strong>關鍵相依:</strong> <br />
- <code>PRD_Chiller_Plant_Optimization_V1.1.md</code> (邏輯約束定義源頭)<br />
- <code>PRD_CLEANER_v2.2.md</code> (SSOT 與職責分離機制)<br />
- <code>PRD_Interface_Contract_v1.0.md</code> (錯誤代碼分層 E350-E399)<br />
- <code>PRD_BATCH_PROCESSOR_v1.3.md</code> (時間基準與 Manifest 傳遞)</p>
<p><strong>預估工時:</strong> 4 ~ 5 個工程天（含約束同步機制、歷史資料驗證、整合測試）</p>
<hr />
<h2 id="1">1. 執行總綱與設計哲學</h2>
<h3 id="11">1.1 核心目標</h3>
<p>建立<strong>ETL階段的設備依賴驗證機制</strong>，將Optimization階段定義的物理邏輯約束（如「開主機必須開水泵」）<strong>反向同步</strong>至資料清洗階段，確保進入模型訓練的歷史資料符合物理現實，避免「主機開但水泵關」等不可能狀態流入下游。</p>
<h3 id="12">1.2 設計原則</h3>
<ol>
<li>
<p><strong>約束單一來源 (Single Source of Constraints)</strong>: <br />
   - 邏輯約束定義維持在 <code>config/optimization/sites/{site}.yaml</code> (Optimization v1.1 定義)<br />
   - ETL階段<strong>唯讀</strong>引用，不複製或重複定義約束<br />
   - 透過 <code>ConstraintSyncManager</code> 在Container初始化時載入並快取</p>
</li>
<li>
<p><strong>分層驗證策略</strong>:<br />
   - <strong>Cleaner階段</strong>: 逐行即時驗證（Row-level Validation），標記異常但不中斷流程（因歷史資料可能確實存在違規）<br />
   - <strong>BatchProcessor階段</strong>: 批次統計驗證（Batch-level Validation），計算約束違反率，寫入Manifest供訓練階段參考<br />
   - <strong>嚴格模式</strong>: 可配置為遇到物理不可能狀態時拋出錯誤（用於新案場首次資料導入檢查）</p>
</li>
<li>
<p><strong>與Optimization零Gap銜接</strong>:<br />
   - 完整支援 Optimization v1.1 定義的5種約束類型：<code>requires</code>, <code>mutex</code>, <code>sequence</code>, <code>min_runtime</code>, <code>min_downtime</code><br />
   - 錯誤代碼與Optimization階段連貫（E800系列為Optimization錯誤，E350-E399為ETL階段對應錯誤）</p>
</li>
<li>
<p><strong>職責分離維護</strong>:<br />
   - 驗證邏輯不寫入 <code>device_role</code>（遵循Cleaner v2.2職責分離原則）<br />
   - 僅讀取Optimization Config中的<code>logic_constraints</code>區塊，與Feature Annotation的<code>device_role</code>區分</p>
</li>
</ol>
<h3 id="13">1.3 與上游模組的關係</h3>
<pre><code class="language-mermaid">graph LR
    A[Optimization Config&lt;br/&gt;sites/{site}.yaml&lt;br/&gt;logic_constraints] --&gt;|ConstraintSyncManager&lt;br/&gt;唯讀載入| B[EquipmentValidator&lt;br/&gt;v1.0]
    C[Feature Annotation&lt;br/&gt;physical_types.yaml] --&gt;|提供設備狀態欄位映射| B
    D[歷史資料&lt;br/&gt;Parser/Cleaner] --&gt;|逐行驗證| B
    B --&gt;|標記PHYSICAL_IMPOSSIBLE| E[Cleaner Output&lt;br/&gt;quality_flags擴充]
    B --&gt;|統計違反率| F[BatchProcessor Manifest&lt;br/&gt;validation_summary]

    style B fill:#f9f,stroke:#333,stroke-width:4px
    style A fill:#bbf,stroke:#00f,stroke-width:2px
</code></pre>
<h3 id="14-optimization-v11-etl">1.4 約束類型對應表 (Optimization v1.1 → ETL)</h3>
<table>
<thead>
<tr>
<th style="text-align: left;">約束類型</th>
<th style="text-align: left;">Optimization定義</th>
<th style="text-align: center;">ETL驗證時機</th>
<th style="text-align: center;">ETL錯誤代碼</th>
<th style="text-align: left;">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>requires</strong></td>
<td style="text-align: left;"><code>if: "chiller_1_on" then: ["chw_pump_1_on"]</code></td>
<td style="text-align: center;">Cleaner逐行驗證</td>
<td style="text-align: center;">E351</td>
<td style="text-align: left;">主機開但水泵關</td>
</tr>
<tr>
<td style="text-align: left;"><strong>mutex</strong></td>
<td style="text-align: left;"><code>devices: ["chiller_1", "chiller_2"]</code></td>
<td style="text-align: center;">Cleaner逐行驗證</td>
<td style="text-align: center;">E352</td>
<td style="text-align: left;">互斥設備同時開啟</td>
</tr>
<tr>
<td style="text-align: left;"><strong>sequence</strong></td>
<td style="text-align: left;"><code>startup: ["ct_1", "pump_1", "chiller_1"]</code></td>
<td style="text-align: center;">BatchProcessor時序分析</td>
<td style="text-align: center;">E353</td>
<td style="text-align: left;">開機順序錯誤（歷史資料）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>min_runtime</strong></td>
<td style="text-align: left;"><code>device: "chiller_1", minutes: 30</code></td>
<td style="text-align: center;">BatchProcessor時長統計</td>
<td style="text-align: center;">E354</td>
<td style="text-align: left;">運行時間不足（異常停機）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>min_downtime</strong></td>
<td style="text-align: left;"><code>device: "chiller_1", minutes: 15</code></td>
<td style="text-align: center;">BatchProcessor時長統計</td>
<td style="text-align: center;">E355</td>
<td style="text-align: left;">停機時間不足（頻繁啟停）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>composite</strong></td>
<td style="text-align: left;">多重約束組合</td>
<td style="text-align: center;">Cleaner綜合驗證</td>
<td style="text-align: center;">E350</td>
<td style="text-align: left;">複合邏輯違反</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="2-interface-contracts">2. 介面契約規範 (Interface Contracts)</h2>
<h3 id="21-input-contract-from-optimization-config">2.1 輸入契約 (Input Contract from Optimization Config)</h3>
<p><strong>檢查點 #9: Optimization Config → EquipmentValidator</strong></p>
<p>透過 <code>ConstraintSyncManager</code> 載入，確保約束定義與Optimization階段完全一致：</p>
<pre><code class="language-python">class ConstraintSyncManager:
    &quot;&quot;&quot;
    約束同步管理器：從Optimization Config唯讀載入邏輯約束
    確保ETL與Optimization使用完全相同的約束定義
    &quot;&quot;&quot;

    def load_constraints(self, site_id: str) -&gt; LogicConstraintSet:
        &quot;&quot;&quot;
        載入流程：
        1. 讀取 config/optimization/sites/{site_id}.yaml
        2. 提取 logic_constraints 區塊
        3. 驗證約束語法（與Optimization使用相同的Pydantic模型）
        4. 建立約束圖（Constraint Graph）供快速查詢
        5. 快取於記憶體（避免重複讀取YAML）

        Returns:
            LogicConstraintSet: 包含所有約束的結構化物件

        Raises:
            E350: 無法載入約束或語法錯誤
        &quot;&quot;&quot;

    def get_equipment_dependencies(self, equipment_id: str) -&gt; List[str]:
        &quot;&quot;&quot;
        查詢設備依賴（requires約束）
        例如：get_equipment_dependencies(&quot;chiller_1&quot;) -&gt; [&quot;chw_pump_1&quot;, &quot;ct_1&quot;]
        &quot;&quot;&quot;

    def get_mutex_groups(self) -&gt; List[Set[str]]:
        &quot;&quot;&quot;
        取得所有互斥設備組（mutex約束）
        &quot;&quot;&quot;

    def validate_constraint_consistency(self) -&gt; bool:
        &quot;&quot;&quot;
        驗證約束一致性（避免矛盾約束，如A依賴B但B與A互斥）
        在Container初始化時執行
        &quot;&quot;&quot;
</code></pre>
<p><strong>載入規格</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">檢查項</th>
<th style="text-align: left;">規格</th>
<th style="text-align: center;">錯誤代碼</th>
<th style="text-align: left;">處理</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Config存在性</strong></td>
<td style="text-align: left;"><code>config/optimization/sites/{site}.yaml</code> 必須存在</td>
<td style="text-align: center;">E350</td>
<td style="text-align: left;">拒絕載入，提示建立Optimization配置</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Constraints區塊</strong></td>
<td style="text-align: left;">必須包含 <code>logic_constraints</code> 欄位（可為空列表）</td>
<td style="text-align: center;">E350-Warn</td>
<td style="text-align: left;">警告無約束，視為自由運行模式</td>
</tr>
<tr>
<td style="text-align: left;"><strong>語法驗證</strong></td>
<td style="text-align: left;">必須符合Optimization v1.1的Pydantic模型</td>
<td style="text-align: center;">E350</td>
<td style="text-align: left;">拒絕載入，提示語法錯誤</td>
</tr>
<tr>
<td style="text-align: left;"><strong>設備ID一致性</strong></td>
<td style="text-align: left;">約束中的設備ID必須存在於Feature Annotation</td>
<td style="text-align: center;">E351-Warn</td>
<td style="text-align: left;">警告未定義設備，可能為配置錯誤</td>
</tr>
</tbody>
</table>
<h3 id="22-output-contract-to-cleanerbatchprocessor">2.2 輸出契約 (Output Contract to Cleaner/BatchProcessor)</h3>
<p><strong>Cleaner階段輸出 (Row-level Flags)</strong>:</p>
<p>擴充 <code>VALID_QUALITY_FLAGS</code> (Interface Contract v1.0定義)，新增ETL階段設備依賴錯誤標記：</p>
<pre><code class="language-python"># src/etl/config_models.py (SSOT擴充)
VALID_QUALITY_FLAGS: Final[List[str]] = [
    # 原有標記 (v2.2)
    &quot;FROZEN&quot;,           # 凍結資料
    &quot;OUTLIER&quot;,          # 離群值
    &quot;PHYSICAL_IMPOSSIBLE&quot;,  # 物理不可能（擴充含義）
    &quot;INSUFFICIENT_DATA&quot;,    # 資料不足
    &quot;MANUAL_REVIEW&quot;,        # 需人工複查
    &quot;INTERPOLATED&quot;,         # 插值補點

    # 新增設備依賴標記 (v1.0)
    &quot;LOGIC_CONSTRAINT_VIOLATION&quot;,  # 邏輯約束違反（通用）
    &quot;REQUIRES_VIOLATION&quot;,          # 依賴缺失（如主機開水泵關）
    &quot;MUTEX_VIOLATION&quot;,             # 互斥違反
    &quot;SEQUENCE_VIOLATION&quot;,          # 順序違反
    &quot;MIN_RUNTIME_VIOLATION&quot;,       # 運行時間不足
    &quot;MIN_DOWNTIME_VIOLATION&quot;,      # 停機時間不足
]
</code></pre>
<p><strong>BatchProcessor階段輸出 (Manifest擴充)</strong>:</p>
<p>在 <code>Manifest.validation_summary</code> 中新增設備依賴統計：</p>
<pre><code class="language-python">class Manifest(BaseModel):
    # ... 原有欄位 ...

    # 新增設備依賴驗證摘要 (Equipment Dependency Validation Summary)
    equipment_validation_summary: Dict = {
        &quot;constraint_set_version&quot;: &quot;1.0&quot;,  # 約束集版本（YAML checksum）
        &quot;validation_timestamp&quot;: &quot;2026-02-13T10:00:00Z&quot;,
        &quot;row_level_stats&quot;: {
            &quot;total_rows_checked&quot;: 10000,
            &quot;logic_violation_rows&quot;: 150,      # 含任一邏輯違反的列數
            &quot;violation_rate_percent&quot;: 1.5
        },
        &quot;constraint_breakdown&quot;: {
            &quot;requires_violations&quot;: 120,       # E351統計
            &quot;mutex_violations&quot;: 20,           # E352統計  
            &quot;sequence_violations&quot;: 5,         # E353統計
            &quot;min_runtime_violations&quot;: 3,      # E354統計
            &quot;min_downtime_violations&quot;: 2      # E355統計
        },
        &quot;equipment_specific_stats&quot;: {
            &quot;chiller_1&quot;: {
                &quot;requires_violations_with&quot;: [&quot;chw_pump_1&quot;],  # 具體違反對象
                &quot;violation_timestamps&quot;: [&quot;2026-01-15T08:30:00Z&quot;, &quot;...&quot;]  # 取樣
            }
        },
        &quot;severity_assessment&quot;: &quot;HIGH&quot;,  # HIGH(&gt;5%)/MEDIUM(1-5%)/LOW(&lt;1%)
        &quot;recommendation&quot;: &quot;建議檢查chiller_1與chw_pump_1的感測器同步性&quot;
    }
</code></pre>
<h3 id="23-optimization">2.3 與Optimization的對齊契約</h3>
<table>
<thead>
<tr>
<th style="text-align: left;">Optimization約束</th>
<th style="text-align: left;">ETL驗證輸出</th>
<th style="text-align: center;">對齊檢查點</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>requires: chiller_1_on → chw_pump_1_on</code></td>
<td style="text-align: left;">標記 <code>REQUIRES_VIOLATION</code> 並記錄設備對</td>
<td style="text-align: center;">#9</td>
</tr>
<tr>
<td style="text-align: left;"><code>mutex: [chiller_1, chiller_2]</code></td>
<td style="text-align: left;">標記 <code>MUTEX_VIOLATION</code> 並記錄衝突設備</td>
<td style="text-align: center;">#9</td>
</tr>
<tr>
<td style="text-align: left;"><code>sequence: startup [ct_1, pump_1, chiller_1]</code></td>
<td style="text-align: left;">標記 <code>SEQUENCE_VIOLATION</code>（歷史時序分析）</td>
<td style="text-align: center;">#9</td>
</tr>
<tr>
<td style="text-align: left;"><code>min_runtime: chiller_1, 30min</code></td>
<td style="text-align: left;">標記 <code>MIN_RUNTIME_VIOLATION</code>（異常短運行）</td>
<td style="text-align: center;">#9</td>
</tr>
<tr>
<td style="text-align: left;"><code>min_downtime: chiller_1, 15min</code></td>
<td style="text-align: left;">標記 <code>MIN_DOWNTIME_VIOLATION</code>（異常短停機）</td>
<td style="text-align: center;">#9</td>
</tr>
</tbody>
</table>
<p><strong>關鍵保證</strong>: <br />
- ETL階段標記為 <code>PHYSICAL_IMPOSSIBLE</code> 的資料，在Optimization階段<strong>必然</strong>會被視為約束違反（Consistency Guarantee）<br />
- ETL標記率與Optimization約束違反率的統計差異不得超過0.1%（Tolerance）</p>
<hr />
<h2 id="3">3. 系統架構與核心模組</h2>
<h3 id="31-constraintsyncmanager">3.1 約束同步管理器 (ConstraintSyncManager)</h3>
<p><strong>檔案</strong>: <code>src/validation/constraint_sync.py</code></p>
<p><strong>職責</strong>: 作為Optimization與ETL之間的橋樑，確保兩端使用完全相同的約束定義</p>
<pre><code class="language-python">class ConstraintSyncManager:
    &quot;&quot;&quot;
    約束同步管理器（單例模式）
    在Container初始化時載入，供Cleaner與BatchProcessor共用
    &quot;&quot;&quot;

    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._constraints_cache = {}
        return cls._instance

    def initialize_for_site(self, site_id: str):
        &quot;&quot;&quot;
        為特定案場初始化約束快取
        必須在Container.__init__中呼叫（早於Cleaner初始化）
        &quot;&quot;&quot;
        config_path = Path(f&quot;config/optimization/sites/{site_id}.yaml&quot;)

        if not config_path.exists():
            raise ConfigurationError(
                f&quot;E350: Optimization配置不存在: {config_path}。 &quot;
                f&quot;請先建立設備依賴約束配置（PRD_Optimization_v1.1）&quot;
            )

        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)

        constraints = config.get('logic_constraints', [])

        # 驗證約束語法（使用與Optimization相同的Pydantic模型）
        try:
            self._constraints_cache[site_id] = LogicConstraintSet(constraints=constraints)
        except ValidationError as e:
            raise ConfigurationError(f&quot;E350: 約束語法錯誤: {e}&quot;)

        self.logger.info(f&quot;案場 {site_id}: 載入 {len(constraints)} 條邏輯約束&quot;)

    def get_constraints(self, site_id: str) -&gt; LogicConstraintSet:
        &quot;&quot;&quot;取得指定案場的約束集&quot;&quot;&quot;
        if site_id not in self._constraints_cache:
            raise RuntimeError(f&quot;E350: 案場 {site_id} 的約束未初始化&quot;)
        return self._constraints_cache[site_id]
</code></pre>
<h3 id="32-equipmentstateresolver">3.2 設備狀態解析器 (EquipmentStateResolver)</h3>
<p><strong>檔案</strong>: <code>src/validation/equipment_state.py</code></p>
<p><strong>職責</strong>: 將原始感測器數值轉換為設備狀態（開/關/未知），處理不同設備類型的判斷邏輯</p>
<pre><code class="language-python">class EquipmentStateResolver:
    &quot;&quot;&quot;
    設備狀態解析器
    根據Feature Annotation的physical_type決定狀態判斷邏輯
    &quot;&quot;&quot;

    # 設備狀態閾值配置（可從Optimization Config覆寫）
    DEFAULT_THRESHOLDS = {
        &quot;chiller&quot;: {&quot;on_threshold_kw&quot;: 10.0, &quot;off_threshold_kw&quot;: 2.0},  # 主機用電判斷
        &quot;pump&quot;: {&quot;on_threshold_hz&quot;: 35.0, &quot;off_threshold_hz&quot;: 5.0},     # 水泵頻率判斷
        &quot;cooling_tower&quot;: {&quot;on_threshold_percent&quot;: 20.0},                 # 冷卻塔轉速判斷
        &quot;valve&quot;: {&quot;on_threshold_percent&quot;: 10.0}                          # 閥門開度判斷
    }

    def __init__(self, annotation_manager: FeatureAnnotationManager, 
                 custom_thresholds: Optional[Dict] = None):
        self.annotation = annotation_manager
        self.thresholds = {**self.DEFAULT_THRESHOLDS, **(custom_thresholds or {})}

    def resolve_state(self, equipment_id: str, row: Dict[str, Any]) -&gt; EquipmentState:
        &quot;&quot;&quot;
        解析設備在單一時間點的狀態

        Returns:
            EquipmentState: Enum [ON, OFF, UNKNOWN, TRANSITION]
        &quot;&quot;&quot;
        # 1. 取得設備對應的感測器欄位（從Annotation查詢）
        sensor_col = self._get_sensor_column(equipment_id)

        if sensor_col not in row or row[sensor_col] is None:
            return EquipmentState.UNKNOWN

        value = row[sensor_col]
        physical_type = self.annotation.get_physical_type(equipment_id)

        # 2. 根據physical_type選擇判斷邏輯
        thresholds = self.thresholds.get(physical_type, {})

        if physical_type in [&quot;chiller&quot;, &quot;power_meter&quot;]:
            # 用電設備：用kW判斷
            if value &gt; thresholds.get(&quot;on_threshold_kw&quot;, 10.0):
                return EquipmentState.ON
            elif value &lt; thresholds.get(&quot;off_threshold_kw&quot;, 2.0):
                return EquipmentState.OFF
            else:
                return EquipmentState.TRANSITION  # 過渡狀態（不穩定）

        elif physical_type in [&quot;pump&quot;, &quot;fan&quot;]:
            # 轉速設備：用Hz或%判斷
            if value &gt; thresholds.get(&quot;on_threshold_hz&quot;, 35.0):
                return EquipmentState.ON
            elif value &lt; thresholds.get(&quot;off_threshold_hz&quot;, 5.0):
                return EquipmentState.OFF
            else:
                return EquipmentState.TRANSITION

        # ... 其他設備類型

        return EquipmentState.UNKNOWN

    def _get_sensor_column(self, equipment_id: str) -&gt; str:
        &quot;&quot;&quot;
        從Feature Annotation查詢設備對應的感測器欄位名稱
        例如：chiller_1 -&gt; chiller_1_kw 或 chiller_1_status
        &quot;&quot;&quot;
        # 優先尋找狀態欄位（_status後綴），其次尋找主要感測器（_kw, _hz等）
        col_config = self.annotation.get_column_config(equipment_id)
        # 實作細節依Annotation schema決定
        return f&quot;{equipment_id}_kw&quot;  # 簡化示例
</code></pre>
<h3 id="33-constraintvalidationengine">3.3 約束驗證引擎 (ConstraintValidationEngine)</h3>
<p><strong>檔案</strong>: <code>src/validation/constraint_engine.py</code></p>
<p><strong>職責</strong>: 執行實際的約束驗證邏輯，支援逐行與批次兩種模式</p>
<pre><code class="language-python">class ConstraintValidationEngine:
    &quot;&quot;&quot;
    約束驗證引擎
    執行Optimization定義的5種約束類型驗證
    &quot;&quot;&quot;

    def __init__(self, constraint_set: LogicConstraintSet, 
                 state_resolver: EquipmentStateResolver):
        self.constraints = constraint_set
        self.state_resolver = state_resolver
        self.violation_history = []  # 記錄違反事件供統計

    def validate_row(self, row: Dict[str, Any], timestamp: datetime) -&gt; List[ConstraintViolation]:
        &quot;&quot;&quot;
        逐行驗證（Cleaner階段使用）

        Returns:
            List[ConstraintViolation]: 該行違反的所有約束
        &quot;&quot;&quot;
        violations = []

        for constraint in self.constraints:
            if constraint.type == &quot;requires&quot;:
                if self._check_requires_violation(constraint, row):
                    violations.append(ConstraintViolation(
                        constraint_type=&quot;requires&quot;,
                        constraint_id=constraint.id,
                        equipment=constraint.if_device,
                        missing_dependencies=constraint.then_devices,
                        timestamp=timestamp,
                        error_code=&quot;E351&quot;
                    ))

            elif constraint.type == &quot;mutex&quot;:
                if self._check_mutex_violation(constraint, row):
                    violations.append(ConstraintViolation(
                        constraint_type=&quot;mutex&quot;,
                        constraint_id=constraint.id,
                        conflicting_devices=constraint.devices,
                        timestamp=timestamp,
                        error_code=&quot;E352&quot;
                    ))

            # sequence, min_runtime, min_downtime在批次階段處理

        return violations

    def validate_batch(self, df: pl.DataFrame) -&gt; BatchValidationReport:
        &quot;&quot;&quot;
        批次驗證（BatchProcessor階段使用）
        處理需要時序分析的約束（sequence, min_runtime, min_downtime）
        &quot;&quot;&quot;
        report = BatchValidationReport()

        # 1. Sequence驗證（開關機順序）
        for constraint in self.constraints.get_by_type(&quot;sequence&quot;):
            violations = self._analyze_sequence_batch(df, constraint)
            report.add_sequence_violations(violations)

        # 2. Min Runtime驗證（最小運行時間）
        for constraint in self.constraints.get_by_type(&quot;min_runtime&quot;):
            violations = self._analyze_runtime_batch(df, constraint, &quot;runtime&quot;)
            report.add_runtime_violations(violations)

        # 3. Min Downtime驗證（最小停機時間）
        for constraint in self.constraints.get_by_type(&quot;min_downtime&quot;):
            violations = self._analyze_runtime_batch(df, constraint, &quot;downtime&quot;)
            report.add_downtime_violations(violations)

        return report

    def _check_requires_violation(self, constraint: RequiresConstraint, 
                                   row: Dict) -&gt; bool:
        &quot;&quot;&quot;
        檢查requires約束違反

        邏輯：若if_device為ON，但任一then_device為OFF，則違反
        &quot;&quot;&quot;
        if_state = self.state_resolver.resolve_state(constraint.if_device, row)

        if if_state != EquipmentState.ON:
            return False  # 前提條件不成立，不檢查

        for dep_device in constraint.then_devices:
            dep_state = self.state_resolver.resolve_state(dep_device, row)
            if dep_state == EquipmentState.OFF:
                return True  # 發現依賴缺失

        return False

    def _check_mutex_violation(self, constraint: MutexConstraint, 
                                row: Dict) -&gt; bool:
        &quot;&quot;&quot;
        檢查mutex約束違反

        邏輯：若互斥組中同時有超過1個設備為ON，則違反
        &quot;&quot;&quot;
        on_count = 0
        for device in constraint.devices:
            state = self.state_resolver.resolve_state(device, row)
            if state == EquipmentState.ON:
                on_count += 1
                if on_count &gt; 1:
                    return True

        return False

    def _analyze_sequence_batch(self, df: pl.DataFrame, 
                                constraint: SequenceConstraint) -&gt; List[Violation]:
        &quot;&quot;&quot;
        批次分析開關機順序

        邏輯：檢查startup順序是否被遵守（後者先開為違反）
        注意：歷史資料通常無法改變，此驗證主要用於標記異常時段
        &quot;&quot;&quot;
        violations = []
        startup_order = constraint.startup  # e.g., [&quot;ct_1&quot;, &quot;pump_1&quot;, &quot;chiller_1&quot;]

        # 轉換狀態時間序列
        state_df = self._convert_to_state_series(df, startup_order)

        # 檢查狀態轉換點
        for i in range(1, len(startup_order)):
            primary = startup_order[i]      # 後開設備
            prerequisite = startup_order[i-1]  # 先開設備

            # 尋找primary的開機時間點
            primary_starts = state_df.filter(
                (pl.col(primary) == &quot;ON&quot;) &amp; 
                (pl.col(primary).shift(1) != &quot;ON&quot;)
            )[&quot;timestamp&quot;]

            for start_time in primary_starts:
                # 檢查此時prerequisite是否已開
                prereq_state_at_start = state_df.filter(
                    pl.col(&quot;timestamp&quot;) &lt;= start_time
                ).tail(1)[prerequisite][0]

                if prereq_state_at_start != &quot;ON&quot;:
                    violations.append(ConstraintViolation(...))

        return violations

    def _analyze_runtime_batch(self, df: pl.DataFrame, 
                               constraint: RuntimeConstraint,
                               mode: str) -&gt; List[Violation]:
        &quot;&quot;&quot;
        分析運行/停機時間是否滿足最小時長要求

        適用於min_runtime（運行時間）與min_downtime（停機時間）
        &quot;&quot;&quot;
        device = constraint.device
        min_minutes = constraint.minutes

        # 計算狀態持續時間
        state_series = self._convert_to_state_series(df, [device])

        # 使用Polars計算狀態段（State Segments）
        segments = self._detect_state_segments(state_series, device)

        violations = []
        for segment in segments:
            duration_minutes = (segment.end_time - segment.start_time).total_seconds() / 60

            if mode == &quot;runtime&quot; and segment.state == &quot;ON&quot; and duration_minutes &lt; min_minutes:
                violations.append(ConstraintViolation(
                    type=&quot;min_runtime&quot;,
                    device=device,
                    actual_minutes=duration_minutes,
                    required_minutes=min_minutes,
                    timestamp=segment.start_time
                ))

            elif mode == &quot;downtime&quot; and segment.state == &quot;OFF&quot; and duration_minutes &lt; min_minutes:
                violations.append(ConstraintViolation(
                    type=&quot;min_downtime&quot;,
                    device=device,
                    actual_minutes=duration_minutes,
                    required_minutes=min_minutes,
                    timestamp=segment.start_time
                ))

        return violations
</code></pre>
<hr />
<h2 id="4-phase-based-implementation">4. 分階段實作計畫 (Phase-Based Implementation)</h2>
<h3 id="phase-0-day-1">Phase 0: 約束同步基礎建設 (Day 1)</h3>
<p><strong>Step 0.1: ConstraintSyncManager實作</strong></p>
<pre><code class="language-python"># src/validation/constraint_sync.py

class LogicConstraintSet(BaseModel):
    &quot;&quot;&quot;約束集資料模型（與Optimization v1.1共享）&quot;&quot;&quot;
    constraints: List[Union[
        RequiresConstraint,
        MutexConstraint, 
        SequenceConstraint,
        RuntimeConstraint
    ]]

    def get_by_type(self, type_name: str) -&gt; List:
        return [c for c in self.constraints if c.type == type_name]

class ConstraintSyncManager:
    # ... （見3.1節）...
    pass
</code></pre>
<p><strong>驗收標準</strong>:<br />
- [ ] 成功載入 <code>cgmh_ty.yaml</code> 的logic_constraints<br />
- [ ] 語法錯誤時拋出E350並提供明確錯誤位置<br />
- [ ] 與Optimization使用相同的Pydantic模型（無轉換誤差）</p>
<p><strong>Step 0.2: EquipmentStateResolver實作</strong></p>
<pre><code class="language-python"># src/validation/equipment_state.py

class EquipmentState(Enum):
    ON = &quot;on&quot;
    OFF = &quot;off&quot;
    UNKNOWN = &quot;unknown&quot;
    TRANSITION = &quot;transition&quot;  # 過渡狀態（閾值區間內）

class EquipmentStateResolver:
    # ... （見3.2節）...

    def validate_thresholds_config(self) -&gt; bool:
        &quot;&quot;&quot;驗證閾值配置合理性（避免on_threshold &lt; off_threshold）&quot;&quot;&quot;
        for eq_type, thresholds in self.thresholds.items():
            if &quot;on_threshold_kw&quot; in thresholds and &quot;off_threshold_kw&quot; in thresholds:
                if thresholds[&quot;on_threshold_kw&quot;] &lt;= thresholds[&quot;off_threshold_kw&quot;]:
                    raise ConfigurationError(
                        f&quot;設備類型 {eq_type} 的on_threshold必須大於off_threshold&quot;
                    )
        return True
</code></pre>
<p><strong>驗收標準</strong>:<br />
- [ ] 正確解析chiller狀態（用電&gt;10kW為ON，&lt;2kW為OFF）<br />
- [ ] 正確解析pump狀態（頻率&gt;35Hz為ON，&lt;5kW為OFF）<br />
- [ ] 數值為Null時返回UNKNOWN</p>
<h3 id="phase-1-cleaner-day-2">Phase 1: Cleaner整合與逐行驗證 (Day 2)</h3>
<p><strong>Step 1.1: Cleaner擴充（整合EquipmentValidator）</strong></p>
<p>修改 <code>src/etl/cleaner.py</code> (v2.2+):</p>
<pre><code class="language-python">class DataCleaner:
    def __init__(self, config: CleanerConfig, 
                 annotation_manager: FeatureAnnotationManager,
                 constraint_manager: Optional[ConstraintSyncManager] = None):  # 新增
        # ... 原有初始化 ...
        self.constraint_manager = constraint_manager
        self.equipment_validator = None

        if constraint_manager:
            self.equipment_validator = ConstraintValidationEngine(
                constraint_set=constraint_manager.get_constraints(config.site_id),
                state_resolver=EquipmentStateResolver(annotation_manager)
            )

    def _semantic_aware_cleaning(self, df: pl.DataFrame) -&gt; pl.DataFrame:
        &quot;&quot;&quot;
        擴充v2.2的語意感知清洗，加入設備依賴驗證
        &quot;&quot;&quot;
        # ... 原有邏輯（凍結檢測、零值檢查）...

        # 新增：設備依賴驗證（逐行）
        if self.equipment_validator:
            df = self._validate_equipment_dependencies(df)

        return df

    def _validate_equipment_dependencies(self, df: pl.DataFrame) -&gt; pl.DataFrame:
        &quot;&quot;&quot;
        逐行驗證設備依賴關係（requires, mutex）
        將違反標記為quality_flags
        &quot;&quot;&quot;
        violations_list = []

        for row_idx in range(len(df)):
            row = df[row_idx].to_dict()
            timestamp = row[&quot;timestamp&quot;]

            # 執行驗證
            violations = self.equipment_validator.validate_row(row, timestamp)

            if violations:
                # 收集所有違反的flags
                flags_to_add = [v.error_code.replace(&quot;E&quot;, &quot;FLAG_&quot;) for v in violations]
                flags_to_add.append(&quot;LOGIC_CONSTRAINT_VIOLATION&quot;)

                # 標記該行（使用Polars的with_row_count輔助）
                violations_list.append((row_idx, flags_to_add))

        # 批量更新quality_flags（避免逐行更新效能問題）
        if violations_list:
            df = self._apply_violation_flags(df, violations_list)

            # 記錄統計
            self.logger.warning(
                f&quot;設備依賴驗證：發現 {len(violations_list)} 行違反，&quot;
                f&quot;類型分布: {self._summarize_violations(violations)}&quot;
            )

        return df

    def _apply_violation_flags(self, df: pl.DataFrame, 
                                violations: List[Tuple[int, List[str]]]) -&gt; pl.DataFrame:
        &quot;&quot;&quot;
        將違反標記應用到DataFrame（使用Polars高效操作）
        &quot;&quot;&quot;
        # 建立flags列的更新映射
        flag_updates = {}
        for row_idx, flags in violations:
            for flag in flags:
                if flag not in flag_updates:
                    flag_updates[flag] = []
                flag_updates[flag].append(row_idx)

        # 使用Polars的when-then鏈更新（或先轉為Pandas處理後轉回，取決於效能）
        # 這裡簡化展示邏輯，實作時應使用Polars原生語法
        for flag, rows in flag_updates.items():
            mask = pl.Series([i in rows for i in range(len(df))])
            df = df.with_columns(
                pl.when(mask).then(
                    pl.col(&quot;quality_flags&quot;).list.concat(pl.lit([flag]))
                ).otherwise(pl.col(&quot;quality_flags&quot;)).alias(&quot;quality_flags&quot;)
            )

        return df
</code></pre>
<p><strong>驗收標準</strong>:<br />
- [ ] requires約束違反正確標記（E351 → FLAG_REQUIRES_VIOLATION）<br />
- [ ] mutex約束違反正確標記（E352 → FLAG_MUTEX_VIOLATION）<br />
- [ ] 效能：處理10萬行資料耗時&lt;5秒（使用Polars向量化操作）</p>
<h3 id="phase-2-batchprocessor-day-3">Phase 2: BatchProcessor整合與批次驗證 (Day 3)</h3>
<p><strong>Step 2.1: BatchProcessor擴充（時序約束驗證）</strong></p>
<p>修改 <code>src/etl/batch_processor.py</code> (v1.3+):</p>
<pre><code class="language-python">class BatchOrchestrator:
    def __init__(self, ...):
        # ... 原有初始化 ...
        self.equipment_validator = ConstraintValidationEngine(
            constraint_set=constraint_manager.get_constraints(config.site_id),
            state_resolver=EquipmentStateResolver(annotation_manager)
        )

    def process_single_file(self, file_path: Path) -&gt; BatchResult:
        # ... 原有流程（解析、清洗）...

        # 新增：批次設備依賴驗證（時序相關）
        validation_report = self.equipment_validator.validate_batch(clean_df)

        # 將驗證報告寫入Manifest
        manifest = self._generate_manifest(
            clean_df,
            column_metadata=column_metadata,
            validation_report=validation_report  # 新增參數
        )

        return BatchResult(
            # ... 原有欄位 ...
            validation_summary=validation_report.to_dict()  # 新增
        )

    def _generate_manifest(self, df, column_metadata, validation_report, ...):
        # ... 原有Manifest生成邏輯 ...

        # 新增equipment_validation_summary
        manifest.equipment_validation_summary = {
            &quot;constraint_set_version&quot;: self._get_constraint_checksum(),
            &quot;validation_timestamp&quot;: datetime.now(timezone.utc).isoformat(),
            &quot;row_level_stats&quot;: {
                &quot;total_rows_checked&quot;: len(df),
                &quot;logic_violation_rows&quot;: validation_report.total_violations,
                &quot;violation_rate_percent&quot;: round(
                    validation_report.total_violations / len(df) * 100, 2
                )
            },
            &quot;constraint_breakdown&quot;: {
                &quot;requires_violations&quot;: len(validation_report.requires_violations),
                &quot;mutex_violations&quot;: len(validation_report.mutex_violations),
                &quot;sequence_violations&quot;: len(validation_report.sequence_violations),
                &quot;min_runtime_violations&quot;: len(validation_report.runtime_violations),
                &quot;min_downtime_violations&quot;: len(validation_report.downtime_violations)
            },
            &quot;equipment_specific_stats&quot;: validation_report.get_equipment_stats(),
            &quot;severity_assessment&quot;: validation_report.assess_severity(),
            &quot;recommendation&quot;: validation_report.generate_recommendation()
        }

        return manifest
</code></pre>
<p><strong>驗收標準</strong>:<br />
- [ ] sequence約束正確檢測（開機順序錯誤時段）<br />
- [ ] min_runtime正確計算（運行&lt;30分鐘的異常短運行）<br />
- [ ] min_downtime正確計算（停機&lt;15分鐘的頻繁啟停）<br />
- [ ] Manifest正確寫入validation_summary</p>
<h3 id="phase-3-day-4">Phase 3: 錯誤代碼與日誌整合 (Day 4)</h3>
<p><strong>Step 3.1: 錯誤代碼實作（E350-E399）</strong></p>
<p>擴充 <code>src/etl/config_models.py</code>:</p>
<pre><code class="language-python"># 設備依賴驗證錯誤代碼（Interface Contract v1.0定義E350-E399區間）
EQUIPMENT_DEPENDENCY_ERROR_CODES = {
    &quot;E350&quot;: {
        &quot;name&quot;: &quot;CONSTRAINT_CONFIG_ERROR&quot;,
        &quot;description&quot;: &quot;無法載入Optimization約束配置或語法錯誤&quot;,
        &quot;stage&quot;: &quot;Container初始化&quot;,
        &quot;severity&quot;: &quot;Critical&quot;
    },
    &quot;E351&quot;: {
        &quot;name&quot;: &quot;REQUIRES_VIOLATION&quot;,
        &quot;description&quot;: &quot;設備依賴約束違反（如主機開但水泵關）&quot;,
        &quot;stage&quot;: &quot;Cleaner逐行驗證&quot;,
        &quot;severity&quot;: &quot;High&quot;,
        &quot;example&quot;: &quot;chiller_1_on=True but chw_pump_1_on=False&quot;
    },
    &quot;E352&quot;: {
        &quot;name&quot;: &quot;MUTEX_VIOLATION&quot;, 
        &quot;description&quot;: &quot;互斥設備同時開啟&quot;,
        &quot;stage&quot;: &quot;Cleaner逐行驗證&quot;,
        &quot;severity&quot;: &quot;High&quot;,
        &quot;example&quot;: &quot;chiller_1_on=True and chiller_2_on=True (mutex group)&quot;
    },
    &quot;E353&quot;: {
        &quot;name&quot;: &quot;SEQUENCE_VIOLATION&quot;,
        &quot;description&quot;: &quot;開關機順序違反（歷史資料時序分析）&quot;,
        &quot;stage&quot;: &quot;BatchProcessor批次驗證&quot;,
        &quot;severity&quot;: &quot;Medium&quot;,
        &quot;example&quot;: &quot;chiller_1 started before ct_1&quot;
    },
    &quot;E354&quot;: {
        &quot;name&quot;: &quot;MIN_RUNTIME_VIOLATION&quot;,
        &quot;description&quot;: &quot;設備運行時間低於最小要求（異常短運行）&quot;,
        &quot;stage&quot;: &quot;BatchProcessor時長統計&quot;,
        &quot;severity&quot;: &quot;Medium&quot;,
        &quot;example&quot;: &quot;chiller_1 runtime=15min, required=30min&quot;
    },
    &quot;E355&quot;: {
        &quot;name&quot;: &quot;MIN_DOWNTIME_VIOLATION&quot;,
        &quot;description&quot;: &quot;設備停機時間低於最小要求（頻繁啟停）&quot;,
        &quot;stage&quot;: &quot;BatchProcessor時長統計&quot;, 
        &quot;severity&quot;: &quot;Medium&quot;,
        &quot;example&quot;: &quot;chiller_1 downtime=5min, required=15min&quot;
    },
    &quot;E356&quot;: {
        &quot;name&quot;: &quot;EQUIPMENT_STATE_AMBIGUOUS&quot;,
        &quot;description&quot;: &quot;設備狀態無法判定（數值在閾值過渡區間）&quot;,
        &quot;stage&quot;: &quot;Cleaner狀態解析&quot;,
        &quot;severity&quot;: &quot;Low&quot;,
        &quot;example&quot;: &quot;chiller_1_kw=5.0 (between off=2 and on=10)&quot;
    },
    &quot;E357&quot;: {
        &quot;name&quot;: &quot;CONSTRAINT_VALIDATION_FAILED&quot;,
        &quot;description&quot;: &quot;批次驗證執行失敗（內部錯誤）&quot;,
        &quot;stage&quot;: &quot;BatchProcessor&quot;,
        &quot;severity&quot;: &quot;High&quot;
    }
}
</code></pre>
<p><strong>Step 3.2: 日誌與監控告警</strong></p>
<pre><code class="language-python"># 在ConstraintValidationEngine中整合

class ConstraintValidationEngine:
    def log_violation(self, violation: ConstraintViolation):
        &quot;&quot;&quot;
        結構化日誌記錄，供ELK/Plumbr等系統收集
        &quot;&quot;&quot;
        log_entry = {
            &quot;timestamp&quot;: violation.timestamp.isoformat(),
            &quot;error_code&quot;: violation.error_code,
            &quot;constraint_type&quot;: violation.constraint_type,
            &quot;equipment_id&quot;: getattr(violation, 'equipment', None),
            &quot;details&quot;: violation.to_dict(),
            &quot;severity&quot;: EQUIPMENT_DEPENDENCY_ERROR_CODES[violation.error_code][&quot;severity&quot;]
        }

        self.logger.warning(f&quot;設備依賴違反: {log_entry}&quot;)

        # 高嚴重度即時告警（可整合PagerDuty/Slack）
        if log_entry[&quot;severity&quot;] == &quot;High&quot;:
            self._send_alert(log_entry)
</code></pre>
<hr />
<h2 id="5-test-plan">5. 測試與驗證計畫 (Test Plan)</h2>
<h3 id="51-unit-tests">5.1 單元測試 (Unit Tests)</h3>
<p><strong>檔案</strong>: <code>tests/test_equipment_dependency.py</code></p>
<table>
<thead>
<tr>
<th style="text-align: left;">測試案例 ID</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">輸入</th>
<th style="text-align: left;">預期結果</th>
<th style="text-align: center;">對應錯誤碼</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">ED-001</td>
<td style="text-align: left;">Requires約束通過</td>
<td style="text-align: left;">chiller_1_on=True, chw_pump_1_on=True</td>
<td style="text-align: left;">無違反</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">ED-002</td>
<td style="text-align: left;">Requires約束違反</td>
<td style="text-align: left;">chiller_1_on=True, chw_pump_1_on=False</td>
<td style="text-align: left;">標記E351</td>
<td style="text-align: center;">E351</td>
</tr>
<tr>
<td style="text-align: left;">ED-003</td>
<td style="text-align: left;">Mutex約束通過</td>
<td style="text-align: left;">chiller_1_on=True, chiller_2_on=False</td>
<td style="text-align: left;">無違反</td>
<td style="text-align: center;">-</td>
</tr>
<tr>
<td style="text-align: left;">ED-004</td>
<td style="text-align: left;">Mutex約束違反</td>
<td style="text-align: left;">chiller_1_on=True, chiller_2_on=True</td>
<td style="text-align: left;">標記E352</td>
<td style="text-align: center;">E352</td>
</tr>
<tr>
<td style="text-align: left;">ED-005</td>
<td style="text-align: left;">Sequence約束檢測</td>
<td style="text-align: left;">ct_1啟動時間 &gt; chiller_1啟動時間</td>
<td style="text-align: left;">標記E353</td>
<td style="text-align: center;">E353</td>
</tr>
<tr>
<td style="text-align: left;">ED-006</td>
<td style="text-align: left;">Min Runtime檢測</td>
<td style="text-align: left;">chiller_1運行20分鐘（要求30分鐘）</td>
<td style="text-align: left;">標記E354</td>
<td style="text-align: center;">E354</td>
</tr>
<tr>
<td style="text-align: left;">ED-007</td>
<td style="text-align: left;">Min Downtime檢測</td>
<td style="text-align: left;">chiller_1停機10分鐘（要求15分鐘）</td>
<td style="text-align: left;">標記E355</td>
<td style="text-align: center;">E355</td>
</tr>
<tr>
<td style="text-align: left;">ED-008</td>
<td style="text-align: left;">狀態過渡區間</td>
<td style="text-align: left;">chiller_1_kw=5.0（閾值2-10之間）</td>
<td style="text-align: left;">標記TRANSITION</td>
<td style="text-align: center;">E356-Warn</td>
</tr>
<tr>
<td style="text-align: left;">ED-009</td>
<td style="text-align: left;">配置載入失敗</td>
<td style="text-align: left;">缺少optimization config</td>
<td style="text-align: left;">拋出E350</td>
<td style="text-align: center;">E350</td>
</tr>
<tr>
<td style="text-align: left;">ED-010</td>
<td style="text-align: left;">閾值配置錯誤</td>
<td style="text-align: left;">on_threshold &lt; off_threshold</td>
<td style="text-align: left;">拋出ConfigError</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<h3 id="52-integration-tests">5.2 整合測試 (Integration Tests)</h3>
<p><strong>檔案</strong>: <code>tests/test_equipment_dependency_integration.py</code></p>
<table>
<thead>
<tr>
<th style="text-align: left;">測試案例 ID</th>
<th style="text-align: left;">描述</th>
<th style="text-align: center;">上游</th>
<th style="text-align: center;">下游</th>
<th style="text-align: left;">驗證目標</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">INT-ED-01</td>
<td style="text-align: left;">Optimization→ETL約束同步</td>
<td style="text-align: center;">Optimization Config v1.1</td>
<td style="text-align: center;">EquipmentValidator v1.0</td>
<td style="text-align: left;">兩端約束定義一致，無轉換誤差</td>
</tr>
<tr>
<td style="text-align: left;">INT-ED-02</td>
<td style="text-align: left;">Cleaner標記傳遞</td>
<td style="text-align: center;">EquipmentValidator</td>
<td style="text-align: center;">Cleaner v2.2</td>
<td style="text-align: left;">quality_flags正確包含REQUIRES_VIOLATION</td>
</tr>
<tr>
<td style="text-align: left;">INT-ED-03</td>
<td style="text-align: left;">Manifest統計寫入</td>
<td style="text-align: center;">BatchProcessor v1.3</td>
<td style="text-align: center;">Feature Engineer v1.3</td>
<td style="text-align: left;">Manifest包含equipment_validation_summary</td>
</tr>
<tr>
<td style="text-align: left;">INT-ED-04</td>
<td style="text-align: left;">長時間執行穩定性</td>
<td style="text-align: center;">1年歷史資料（百萬行）</td>
<td style="text-align: center;">BatchProcessor</td>
<td style="text-align: left;">記憶體使用&lt;4GB，執行時間&lt;2分鐘</td>
</tr>
<tr>
<td style="text-align: left;">INT-ED-05</td>
<td style="text-align: left;">與Optimization交叉驗證</td>
<td style="text-align: center;">同一份CSV</td>
<td style="text-align: center;">Optimization v1.1 + ETL v1.0</td>
<td style="text-align: left;">兩端標記的違反率差異&lt;0.1%</td>
</tr>
</tbody>
</table>
<h3 id="53-acceptance-tests">5.3 驗收測試 (Acceptance Tests)</h3>
<p><strong>場景1：長庚醫院案場實料驗證</strong><br />
- 輸入：cgmh_ty_202501.csv（含已知的chiller_1與chw_pump_1同步問題時段）<br />
- 預期：正確標記2025-01-15 08:30-09:15的REQUIRES_VIOLATION（該時段主機開但水泵關）</p>
<p><strong>場景2：頻繁啟停檢測</strong><br />
- 輸入：模擬chiller_1在1小時內開關3次的資料<br />
- 預期：標記2次MIN_DOWNTIME_VIOLATION（停機時間不足15分鐘）</p>
<hr />
<h2 id="6-risk-assessment">6. 風險評估與緩解 (Risk Assessment)</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">風險</th>
<th style="text-align: center;">嚴重度</th>
<th style="text-align: center;">可能性</th>
<th style="text-align: left;">緩解措施</th>
<th style="text-align: center;">狀態</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>閾值設定錯誤</strong>（設備狀態誤判）</td>
<td style="text-align: center;">🔴 High</td>
<td style="text-align: center;">Medium</td>
<td style="text-align: left;">閾值配置與Optimization共用；提供Validation Tool供工程師確認狀態判讀正確性</td>
<td style="text-align: center;">已規劃</td>
</tr>
<tr>
<td style="text-align: left;"><strong>歷史資料雜訊</strong>（感測器誤差導致狀態閃爍）</td>
<td style="text-align: center;">🟡 Medium</td>
<td style="text-align: center;">High</td>
<td style="text-align: left;">引入TRANSITION狀態（閾值區間內不判定）；支援資料平滑前處理</td>
<td style="text-align: center;">已規劃</td>
</tr>
<tr>
<td style="text-align: left;"><strong>約束定義漂移</strong>（Optimization更新但ETL未同步）</td>
<td style="text-align: center;">🔴 High</td>
<td style="text-align: center;">Medium</td>
<td style="text-align: left;">Container初始化時強制驗證Config checksum；版本不匹配時拋出E350</td>
<td style="text-align: center;">已規劃</td>
</tr>
<tr>
<td style="text-align: left;"><strong>效能瓶頸</strong>（百萬行資料處理過慢）</td>
<td style="text-align: center;">🟡 Medium</td>
<td style="text-align: center;">Medium</td>
<td style="text-align: left;">使用Polars向量化操作；狀態解析快取；支援分批處理</td>
<td style="text-align: center;">已驗證</td>
</tr>
<tr>
<td style="text-align: left;"><strong>與Feature Engineer職責重疊</strong>（FE也做類似驗證）</td>
<td style="text-align: center;">🟢 Low</td>
<td style="text-align: center;">Low</td>
<td style="text-align: left;">明確區分：ETL驗證歷史資料物理可能性，FE驗證特徵工程邏輯；文件標註</td>
<td style="text-align: center;">已說明</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="7-version-compatibility">7. 版本相容性矩陣 (Version Compatibility)</h2>
<table>
<thead>
<tr>
<th style="text-align: center;">Optimization</th>
<th style="text-align: center;">EquipmentValidator</th>
<th style="text-align: center;">Cleaner</th>
<th style="text-align: center;">BatchProcessor</th>
<th style="text-align: center;">相容性</th>
<th style="text-align: left;">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">v1.1</td>
<td style="text-align: center;"><strong>v1.0</strong></td>
<td style="text-align: center;">v2.2+</td>
<td style="text-align: center;">v1.3+</td>
<td style="text-align: center;">✅ <strong>完全相容</strong></td>
<td style="text-align: left;">推薦配置，約束同步完整</td>
</tr>
<tr>
<td style="text-align: center;">v1.1</td>
<td style="text-align: center;"><strong>v1.0</strong></td>
<td style="text-align: center;">v2.1</td>
<td style="text-align: center;">v1.3+</td>
<td style="text-align: center;">⚠️ <strong>部分相容</strong></td>
<td style="text-align: left;">Cleaner v2.1無SSOT Flags擴充，需降級處理</td>
</tr>
<tr>
<td style="text-align: center;">v1.0</td>
<td style="text-align: center;"><strong>v1.0</strong></td>
<td style="text-align: center;">任意</td>
<td style="text-align: center;">任意</td>
<td style="text-align: center;">❌ <strong>不相容</strong></td>
<td style="text-align: left;">Optimization v1.0缺少min_runtime/min_downtime定義</td>
</tr>
<tr>
<td style="text-align: center;">v1.1</td>
<td style="text-align: center;"><strong>v1.0</strong></td>
<td style="text-align: center;">v2.2+</td>
<td style="text-align: center;">v1.2</td>
<td style="text-align: center;">⚠️ <strong>部分相容</strong></td>
<td style="text-align: left;">BatchProcessor v1.2無Manifest擴充欄位，統計資訊遺失</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="8-deliverables">8. 交付物清單 (Deliverables)</h2>
<h3 id="81">8.1 程式碼檔案</h3>
<ol>
<li><code>src/validation/constraint_sync.py</code> - ConstraintSyncManager實作</li>
<li><code>src/validation/equipment_state.py</code> - EquipmentStateResolver實作  </li>
<li><code>src/validation/constraint_engine.py</code> - ConstraintValidationEngine實作</li>
<li><code>src/validation/models.py</code> - 約束資料模型（與Optimization共用）</li>
<li><code>src/etl/cleaner.py</code> (更新) - 整合設備依賴驗證（逐行）</li>
<li><code>src/etl/batch_processor.py</code> (更新) - 整合批次驗證與Manifest輸出</li>
</ol>
<h3 id="82">8.2 配置文件</h3>
<ol start="7">
<li><code>config/validation/equipment_thresholds.yaml</code> - 設備狀態閾值預設值（可依案場覆寫）</li>
</ol>
<h3 id="83">8.3 測試檔案</h3>
<ol start="8">
<li><code>tests/test_equipment_dependency.py</code> - 單元測試（覆蓋E350-E356）</li>
<li><code>tests/test_equipment_dependency_integration.py</code> - 整合測試（含效能測試）</li>
<li><code>tests/fixtures/sample_constraints.yaml</code> - 測試用約束配置</li>
</ol>
<h3 id="84">8.4 文件檔案</h3>
<ol start="11">
<li><code>docs/validation/PRD_Equipment_Dependency_Validation_v1.0.md</code> - 本文件</li>
<li><code>docs/validation/CONSTRAINT_SYNC_GUIDE.md</code> - 約束同步操作手冊（供維運人員）</li>
<li><code>docs/validation/TROUBLESHOOTING.md</code> - 常見錯誤排查（E351-E356處理指引）</li>
</ol>
<hr />
<h2 id="9-sign-off-checklist">9. 驗收簽核 (Sign-off Checklist)</h2>
<h3 id="91">9.1 功能驗收</h3>
<ul>
<li>[ ] <strong>E350驗證</strong>：缺少Optimization Config時正確拋出E350並指引建立配置</li>
<li>[ ] <strong>E351驗證</strong>：chiller_1_on=True但chw_pump_1_on=False時正確標記REQUIRES_VIOLATION</li>
<li>[ ] <strong>E352驗證</strong>：互斥設備同時開啟時正確標記MUTEX_VIOLATION  </li>
<li>[ ] <strong>E353驗證</strong>：開機順序違反（如先開主機後開冷卻塔）正確標記SEQUENCE_VIOLATION</li>
<li>[ ] <strong>E354驗證</strong>：運行時間&lt;30分鐘正確標記MIN_RUNTIME_VIOLATION</li>
<li>[ ] <strong>E355驗證</strong>：停機時間&lt;15分鐘正確標記MIN_DOWNTIME_VIOLATION</li>
<li>[ ] <strong>Manifest輸出</strong>：BatchProcessor輸出的Manifest包含完整的equipment_validation_summary</li>
<li>[ ] <strong>閾值配置</strong>：可從Optimization Config讀取自定義閾值（覆寫預設值）</li>
</ul>
<h3 id="92">9.2 整合驗收</h3>
<ul>
<li>[ ] <strong>Optimization一致性</strong>：與Optimization v1.1使用相同的Pydantic約束模型</li>
<li>[ ] <strong>Cleaner整合</strong>：逐行驗證不影響原有v2.2功能（職責分離維持）</li>
<li>[ ] <strong>BatchProcessor整合</strong>：批次驗證不影響原有v1.3功能（Manifest格式擴充）</li>
<li>[ ] <strong>錯誤代碼</strong>：所有錯誤代碼符合Interface Contract v1.0的E350-E399分層</li>
<li>[ ] <strong>效能</strong>：10萬行資料處理時間&lt;5秒，記憶體使用&lt;2GB</li>
</ul>
<h3 id="93">9.3 文件驗收</h3>
<ul>
<li>[ ] 維運手冊包含E351-E356的處理指引（SOP）</li>
<li>[ ] 包含與Optimization v1.1的對照表（確認無Gap）</li>
<li>[ ] 包含閾值調整指南（供現場工程師校正設備狀態判斷）</li>
</ul>
<hr />
<h2 id="10-optimization-v11">10. 附錄：與Optimization v1.1約束對照</h2>
<table>
<thead>
<tr>
<th style="text-align: left;">Optimization欄位</th>
<th style="text-align: left;">EquipmentValidator對應</th>
<th style="text-align: left;">備註</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>logic_constraints[].type</code></td>
<td style="text-align: left;">驗證方法分派</td>
<td style="text-align: left;">requires/mutex/sequence/min_runtime/min_downtime</td>
</tr>
<tr>
<td style="text-align: left;"><code>logic_constraints[].if</code></td>
<td style="text-align: left;"><code>RequiresConstraint.if_device</code></td>
<td style="text-align: left;">觸發條件設備</td>
</tr>
<tr>
<td style="text-align: left;"><code>logic_constraints[].then</code></td>
<td style="text-align: left;"><code>RequiresConstraint.then_devices</code></td>
<td style="text-align: left;">依賴設備列表</td>
</tr>
<tr>
<td style="text-align: left;"><code>logic_constraints[].devices</code></td>
<td style="text-align: left;"><code>MutexConstraint.devices</code></td>
<td style="text-align: left;">互斥設備組</td>
</tr>
<tr>
<td style="text-align: left;"><code>logic_constraints[].startup</code></td>
<td style="text-align: left;"><code>SequenceConstraint.startup</code></td>
<td style="text-align: left;">開機順序列表</td>
</tr>
<tr>
<td style="text-align: left;"><code>logic_constraints[].minutes</code></td>
<td style="text-align: left;"><code>RuntimeConstraint.minutes</code></td>
<td style="text-align: left;">最小時間（分鐘）</td>
</tr>
<tr>
<td style="text-align: left;"><code>equipment[].min_load_percent</code></td>
<td style="text-align: left;"><code>EquipmentStateResolver.thresholds</code></td>
<td style="text-align: left;">設備狀態閾值來源</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>關鍵設計確認</strong>:<br />
1. <strong>零Gap保證</strong>：ETL階段標記的<code>PHYSICAL_IMPOSSIBLE</code>與Optimization階段的約束違反定義完全一致<br />
2. <strong>SSOT維護</strong>：約束定義唯一位於Optimization Config，ETL唯讀引用，不複製<br />
3. <strong>職責分離</strong>：EquipmentValidator不處理<code>device_role</code>（這是Feature Annotation的職責），僅處理<code>logic_constraints</code><br />
4. <strong>向量化效能</strong>：使用Polars進行批次處理，避免Python迴圈效能瓶頸<br />
5. <strong>可追溯性</strong>：所有約束違反記錄時間戳、設備ID、違反類型，寫入Manifest供訓練階段參考<br />
```</p>
</body>
</html>