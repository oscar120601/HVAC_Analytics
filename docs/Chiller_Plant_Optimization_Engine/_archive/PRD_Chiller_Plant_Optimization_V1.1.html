<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PRD_Chiller_Plant_Optimization_V1.1</title>

<style>
body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
    font-size: 16px;
    line-height: 1.5;
    word-wrap: break-word;
    color: #24292e;
    background-color: #fff;
    max-width: 900px;
    margin: 0 auto;
    padding: 2rem;
}
h1, h2, h3, h4, h5, h6 {
    margin-top: 24px;
    margin-bottom: 16px;
    font-weight: 600;
    line-height: 1.25;
}
h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
h3 { font-size: 1.25em; }
code {
    padding: 0.2em 0.4em;
    margin: 0;
    font-size: 85%;
    background-color: #f6f8fa;
    border-radius: 6px;
    font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
}
pre {
    padding: 16px;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f6f8fa;
    border-radius: 6px;
}
pre code {
    display: inline;
    padding: 0;
    margin: 0;
    overflow: visible;
    line-height: inherit;
    word-wrap: normal;
    background-color: initial;
    border: 0;
}
blockquote {
    padding: 0 1em;
    color: #6a737d;
    border-left: 0.25em solid #dfe2e5;
    margin: 0;
}
table {
    display: block;
    width: 100%;
    margin-top: 0;
    margin-bottom: 16px;
    overflow: auto;
    border-spacing: 0;
    border-collapse: collapse;
}
table th, table td {
    padding: 6px 13px;
    border: 1px solid #dfe2e5;
}
table tr {
    background-color: #fff;
    border-top: 1px solid #c6cbd1;
}
table tr:nth-child(2n) {
    background-color: #f6f8fa;
}
a { color: #0366d6; text-decoration: none; }
a:hover { text-decoration: underline; }
hr {
    height: 0.25em;
    padding: 0;
    margin: 24px 0;
    background-color: #e1e4e8;
    border: 0;
}
</style>

</head>
<body>
<h1 id="prd-v11-chiller-plant-optimization-engine">PRD v1.1: 冰水主機房最佳化引擎 (Chiller Plant Optimization Engine)</h1>
<h1 id="_1">離線建議模式：設備組合最佳化與節能評估</h1>
<p><strong>文件版本:</strong> v1.1 (System-Level Optimization &amp; Model Registry Integration)<br />
<strong>日期:</strong> 2026-02-13<br />
<strong>負責人:</strong> Oscar Chang<br />
<strong>目標模組:</strong> <code>src/optimization/engine.py</code>, <code>src/optimization/constraints.py</code>, <code>src/optimization/scenarios.py</code>, <code>src/optimization/model_interface.py</code><br />
<strong>上游契約:</strong> <code>src/modeling/training_pipeline.py</code> (v1.2+, Model Registry Index)<br />
<strong>關鍵相依:</strong> <code>src/features/annotation_manager.py</code> (v1.2+, 提供物理限制與設備角色)<br />
<strong>預估工時:</strong> 6 ~ 7 個工程天（含模型註冊表整合、特徵向量化、系統級黑盒優化）</p>
<hr />
<h2 id="1">1. 執行總綱與設計哲學</h2>
<h3 id="11">1.1 核心目標</h3>
<p>建立<strong>離線配置最佳化引擎</strong>，採用<strong>系統級黑盒建模（System-Level Blackbox）</strong>策略，支援兩種工程決策模式：</p>
<ol>
<li><strong>負載驅動模式 (Load-Driven)</strong>：給定目標冷凍噸 RT，輸出最佳設備組合（開幾台主機、水泵頻率、冷卻水塔轉速）以達到最低總耗電 kW</li>
<li><strong>效率驅動模式 (Efficiency-Driven)</strong>：給定目標效率 kW/RT，反推設備參數配置，並提供改善前後節能量評估</li>
</ol>
<h3 id="12">1.2 設計原則</h3>
<ol>
<li><strong>系統級黑盒優先</strong>: 採用 Model Training v1.2 的 <code>system_total_kw</code> 作為單一預測目標，透過 Model Registry Index 載入，確保預測精度與設備耦合效應（Copula effect）的完整性</li>
<li><strong>混合整數規劃 (MIP) + 連續優化</strong>：設備啟停為離散變數（0/1），頻率轉速為連續變數（Hz/%）</li>
<li><strong>邏輯約束優先</strong>：設備啟停需符合物理依賴關係（如開主機必須開對應冷卻水塔），再進行能耗優化</li>
<li><strong>多案場繼承</strong>：支援 <code>base.yaml</code> → <code>site.yaml</code> 的設定繼承，不同案場可覆寫設備數量、效率曲線、約束條件</li>
<li><strong>模型版本綁定</strong>：載入 Model Training v1.2 輸出的模型時，強制驗證 <code>model_registry_index.json</code> 中的 <code>annotation_checksum</code> 與當前 Feature Annotation v1.2 的相容性</li>
<li><strong>特徵向量化層</strong>：明確定義設備配置（config）到模型特徵向量（feature vector）的轉換層，確保與訓練時特徵工程一致</li>
<li><strong>離線報告輸出</strong>：產生工程師可讀的優化建議報告（Markdown + JSON 雙格式），非即時控制介面</li>
</ol>
<h3 id="13">1.3 與上游模組的關係</h3>
<pre><code class="language-mermaid">graph LR
    A[Model Training v1.2&lt;br/&gt;Model Registry Index] --&gt;|載入 system_total_kw&lt;br/&gt;驗證 checksum| B[Optimization Engine v1.1]
    C[Feature Annotation v1.2&lt;br/&gt;physical_types.yaml] --&gt;|物理限制&lt;br/&gt;valid_range| B
    D[Optimization Config&lt;br/&gt;sites/{site_id}.yaml] --&gt;|邏輯約束&lt;br/&gt;設備依賴關係| B
    E[工程師輸入&lt;br/&gt;RT 或 kW/RT 目標] --&gt;|最佳化目標| B
    F[環境資料&lt;br/&gt;weather.csv] --&gt;|外氣條件| B
    B --&gt;|配置建議| G[離線報告&lt;br/&gt;改善前/後評估]

    style B fill:#f9f,stroke:#333,stroke-width:4px
    style G fill:#bbf,stroke:#00f,stroke-width:2px
</code></pre>
<h3 id="14">1.4 訓練模式銜接策略</h3>
<p>本引擎<strong>預設採用 System-Level 黑盒模式</strong>（對應 Training v1.2 模式 A），原因：<br />
1. 考慮設備間耦合效應（Copula effect），預測精度最高<br />
2. 簡化優化邏輯（單一預測目標）<br />
3. 與 Model Registry Index 標準格式無縫整合</p>
<p><strong>當 Training 採用 Hybrid 模式（模式 C）時</strong>：<br />
- Optimization Engine 以 <code>system_total_kw</code> 為主要預測依據（必要）<br />
- Component-Level 模型（<code>chiller_1_kw</code> 等）僅用於節能報告中的耗電佔比分析（選用）<br />
- 若 System Model 與 Component Models 加總差異 &gt;5%，觸發警告 E805，但仍以 System Model 為準</p>
<hr />
<h2 id="2-interface-contracts">2. 介面契約規範 (Interface Contracts)</h2>
<h3 id="21-input-contract-from-model-training-v12">2.1 輸入契約 (Input Contract from Model Training v1.2)</h3>
<p><strong>檢查點 #8: Model Training → Optimization Engine</strong></p>
<p>Optimization Engine 不再直接載入個別 <code>.joblib</code> 檔案，而是透過 <strong>Model Registry Index</strong> 統一管理：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">檢查項</th>
<th style="text-align: left;">規格</th>
<th style="text-align: center;">錯誤代碼</th>
<th style="text-align: left;">處理</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Registry Index 存在</strong></td>
<td style="text-align: left;"><code>models/{site_id}/model_registry_index.json</code> 必須存在</td>
<td style="text-align: center;">E801</td>
<td style="text-align: left;">拒絕載入</td>
</tr>
<tr>
<td style="text-align: left;"><strong>目標模型可用</strong></td>
<td style="text-align: left;"><code>system_total_kw</code> 必須在 <code>available_models</code> 中且 <code>optional: false</code></td>
<td style="text-align: center;">E804</td>
<td style="text-align: left;">拒絕載入</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Annotation 版本相容</strong></td>
<td style="text-align: left;"><code>annotation_checksum</code> 比對當前 FeatureAnnotationManager</td>
<td style="text-align: center;">E802</td>
<td style="text-align: left;">拒絕載入</td>
</tr>
<tr>
<td style="text-align: left;"><strong>特徵維度對齊</strong></td>
<td style="text-align: left;"><code>feature_count</code> 與 Optimization Config 特徵數一致</td>
<td style="text-align: center;">E803</td>
<td style="text-align: left;">拒絕載入</td>
</tr>
<tr>
<td style="text-align: left;"><strong>模型檔案完整性</strong></td>
<td style="text-align: left;">Manifest 中引用的 <code>.joblib</code> 檔案存在且 checksum 驗證通過</td>
<td style="text-align: center;">E801</td>
<td style="text-align: left;">拒絕載入</td>
</tr>
</tbody>
</table>
<p><strong>ModelRegistry 實作規範</strong>：</p>
<pre><code class="language-python">class ModelRegistry:
    &quot;&quot;&quot;
    模型註冊表：載入與驗證 Model Training v1.2 輸出
    統一透過 model_registry_index.json 作為入口
    &quot;&quot;&quot;

    def load_from_registry(
        self, 
        site_id: str, 
        target_id: str = &quot;system_total_kw&quot;,
        pinned_timestamp: Optional[str] = None
    ) -&gt; MultiModelArtifact:
        &quot;&quot;&quot;
        載入流程：
        1. 讀取 models/{site_id}/model_registry_index.json
        2. 驗證 schema_version &gt;= 1.2
        3. 驗證 annotation_checksum（E802）
        4. 依 target_id 找到對應 ModelEntry
        5. 若 pinned_timestamp 指定，載入該版本；否則載入最新版本
        6. 載入該 target 的 ensemble_manifest.json
        7. 驗證 model 檔案 checksum
        8. 回傳 MultiModelArtifact（含最佳模型與備援模型）

        Args:
            site_id: 案場識別碼
            target_id: 預設 &quot;system_total_kw&quot;，可選 &quot;chiller_1_kw&quot; 等（Hybrid 診斷用）
            pinned_timestamp: 鎖定特定版本（格式：YYYYMMDD_HHMMSS），確保重現性

        Raises:
            E801: Model Registry Index 不存在或模型檔案遺失
            E802: Annotation checksum 不匹配
            E804: 請求的 target_id 不可用
        &quot;&quot;&quot;

    def validate_hybrid_consistency(
        self, 
        config: Dict, 
        ambient: Dict,
        tolerance: float = 0.05
    ) -&gt; Tuple[bool, float]:
        &quot;&quot;&quot;
        Hybrid 模式一致性檢查：
        - 使用 system_total_kw 預測總耗電
        - 使用各 component models 預測並加總
        - 比較兩者差異百分比

        Returns:
            (is_consistent, discrepancy_percent)
            is_consistent: discrepancy &lt;= tolerance
        &quot;&quot;&quot;
</code></pre>
<h3 id="22-feature-vectorization">2.2 特徵向量化契約 (Feature Vectorization)</h3>
<p><strong>檢查點 #8.5: Optimization Config → Model Features</strong></p>
<p>將設備配置（離散+連續變數）轉換為模型輸入特徵向量，需與 Training v1.2 的特徵工程邏輯完全一致：</p>
<pre><code class="language-python">class FeatureVectorizer:
    &quot;&quot;&quot;
    將 Optimization 的設備配置轉換為 ML 模型輸入特徵
    確保特徵順序、名稱、縮放方式與訓練時一致
    &quot;&quot;&quot;

    def __init__(self, site_config: OptimizationConfig, model_features: List[str]):
        &quot;&quot;&quot;
        Args:
            site_config: 案場設備配置（含設備 ID 對應關係）
            model_features: 從 ModelEntry 讀取的特徵名稱列表（順序敏感）
        &quot;&quot;&quot;
        self.model_features = model_features
        self.feature_scalers = site_config.feature_scalers  # 從 Training 繼承的縮放參數

    def vectorize(
        self, 
        discrete_vars: Dict[str, bool],      # 如 {&quot;chiller_1_on&quot;: True, &quot;chiller_2_on&quot;: False}
        continuous_vars: Dict[str, float],   # 如 {&quot;chiller_1_load_percent&quot;: 0.6, &quot;chw_pump_1_hz&quot;: 45}
        ambient: Dict[str, float]            # 如 {&quot;wet_bulb_temp&quot;: 26.5, &quot;dry_bulb_temp&quot;: 32.0}
    ) -&gt; np.ndarray:
        &quot;&quot;&quot;
        轉換邏輯：
        1. 合併 discrete_vars（bool → float 1.0/0.0）
        2. 合併 continuous_vars（單位轉換：Hz→%，RT→正規化等）
        3. 合併 ambient（外氣條件）
        4. 依照 self.model_features 的順序排列
        5. 套用特徵縮放（若訓練時有使用 StandardScaler）

        Returns:
            np.ndarray: shape (n_features,)
        &quot;&quot;&quot;

    def validate_alignment(self) -&gt; bool:
        &quot;&quot;&quot;
        驗證 E803：確保 Optimization Config 能產生所有 model_features 所需的欄位
        回傳 False 表示缺少必要特徵，無法進行預測
        &quot;&quot;&quot;
</code></pre>
<h3 id="23">2.3 約束條件來源（雙軌制）</h3>
<table>
<thead>
<tr>
<th style="text-align: left;">約束類型</th>
<th style="text-align: left;">來源</th>
<th style="text-align: left;">內容範例</th>
<th style="text-align: center;">嚴格度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>物理限制</strong></td>
<td style="text-align: left;">Feature Annotation v1.2</td>
<td style="text-align: left;"><code>chiller_out_temp &gt;= 6.5</code> (°C), <code>pump_hz &lt;= 60</code></td>
<td style="text-align: center;">硬約束 (Hard)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>邏輯約束</strong></td>
<td style="text-align: left;">Optimization Config v1.1</td>
<td style="text-align: left;"><code>chiller_1_on → ct_1_on</code> (開主機1必須開冷卻塔1)</td>
<td style="text-align: center;">硬約束 (Hard)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>運行邊界</strong></td>
<td style="text-align: left;">Optimization Config v1.1</td>
<td style="text-align: left;"><code>min_chiller_load = 30%</code> (最低載率限制)</td>
<td style="text-align: center;">硬約束 (Hard)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>偏好約束</strong></td>
<td style="text-align: left;">Optimization Config v1.1</td>
<td style="text-align: left;"><code>prefer_backup = true</code> (優先使用備用機組)</td>
<td style="text-align: center;">軟約束 (Soft)</td>
</tr>
</tbody>
</table>
<h3 id="24">2.4 工程師輸入介面</h3>
<pre><code class="language-python">class OptimizationRequest(BaseModel):
    &quot;&quot;&quot;最佳化請求（離線模式）&quot;&quot;&quot;

    # 案場識別
    site_id: str

    # 模式選擇（互斥）
    mode: Literal[&quot;load_driven&quot;, &quot;efficiency_driven&quot;]

    # 模式 A：負載驅動
    target_rt: Optional[float] = None  # 目標冷凍噸，例如 500.0 RT

    # 模式 B：效率驅動
    target_kw_per_rt: Optional[float] = None  # 目標效率，例如 0.65 kW/RT

    # 環境條件（對應審查報告 3.1 建議）
    ambient_conditions: Optional[Dict[str, float]] = None  # 即時指定
    ambient_file: Optional[str] = None  # 從 CSV 檔案讀取歷史天氣資料進行批次模擬

    # 運行邊界（可選，覆寫 Config 預設）
    constraints_override: Optional[Dict] = None

    # 當前狀態（用於改善前後比較）
    current_config: Optional[Dict] = None  # 例如 {&quot;chiller_count&quot;: 2, &quot;pump_hz&quot;: 45, ...}

    # 模型版本控制（v1.1 新增）
    model_version_policy: Optional[Dict] = {
        &quot;auto_update&quot;: False,                    # 是否自動使用最新訓練的模型
        &quot;pinned_timestamp&quot;: None,                # 鎖定特定版本（確保重現性）
        &quot;fallback_on_error&quot;: True                # 載入失敗時是否允許使用次佳模型
    }

class OptimizationResponse(BaseModel):
    &quot;&quot;&quot;最佳化回應&quot;&quot;&quot;

    # 最佳化結果
    recommended_config: Dict  # 設備組合與參數
    predicted_kw: float       # 預測總耗電（來自 system_total_kw 模型）
    predicted_kw_per_rt: float  # 預測效率

    # 預測信心區間（若使用 Random Forest 或啟用區間預測）
    prediction_interval: Optional[Dict[str, float]] = None  # {&quot;lower&quot;: 290, &quot;upper&quot;: 310}

    # 改善評估（若提供 current_config）
    baseline_kw: Optional[float] = None
    savings_kw: Optional[float] = None
    savings_percent: Optional[float] = None
    annual_savings_estimate: Optional[float] = None  # 年度預估節電量 (kWh)

    # Hybrid 模式診斷資訊（若 Component Models 可用）
    component_breakdown: Optional[Dict[str, float]] = None  # {&quot;chiller_1_kw&quot;: 150, &quot;pump_kw&quot;: 30, ...}
    hybrid_consistency_check: Optional[Dict] = None  # {&quot;system_pred&quot;: 300, &quot;component_sum&quot;: 295, &quot;discrepancy&quot;: 1.7%}

    # 約束狀態
    constraint_violations: List[str]  # 若有軟約束違反
    binding_constraints: List[str]    # 起作用的有效約束

    # 模型資訊
    model_used: str                   # 實際使用的模型名稱（如 &quot;xgboost&quot;）
    model_timestamp: str              # 模型版本時間戳

    # 報告
    recommendation_text: str  # 工程師可讀的建議說明
    scenario_analysis: Optional[Dict] = None  # 多情境比較（如開1台vs2台）
</code></pre>
<hr />
<h2 id="3">3. 系統架構與核心模組</h2>
<h3 id="31-feature-annotation-v12">3.1 多案場配置系統（繼承 Feature Annotation v1.2 模式）</h3>
<p><strong>檔案結構</strong>：</p>
<pre><code>config/optimization/
├── base.yaml                    # 基礎設備模型與通用約束
├── sites/
│   ├── cgmh_ty.yaml            # 長庚醫院桃園院區（繼承 base）
│   └── farglory_o3.yaml        # 遠雄 O3（繼承 base）
└── schemas/
    └── optimization_schema.json # JSON Schema 驗證
</code></pre>
<p><strong>base.yaml 範例（v1.1 更新版）</strong>：</p>
<pre><code class="language-yaml">schema_version: &quot;1.1&quot;
inherit: &quot;none&quot;

# 模型註冊表設定（v1.1 新增：取代個別 model_file）
model_registry:
  index_file: &quot;models/{site_id}/model_registry_index.json&quot;  # 統一入口
  default_target: &quot;system_total_kw&quot;                         # 預設使用系統級模型
  fallback_to_components: false                             # 是否允許退回到 Component-Level 加總
  version_policy:
    auto_update: false                                      # 預設鎖定版本，避免重現性問題
    pinned_timestamp: null                                  # 指定版本，如 &quot;20260213_120000&quot;

# 設備清單與規格（移除 model_file，改為純配置）
equipment:
  chillers:
    - id: chiller_1
      type: centrifugal
      capacity_rt: 300
      min_load_percent: 30  # 最低載率 30%
      dependencies: [&quot;chw_pump_1&quot;, &quot;ct_1&quot;]  # 邏輯約束：開機需開啟的輔助設備
      device_role: primary

    - id: chiller_2
      type: screw
      capacity_rt: 200
      min_load_percent: 25
      dependencies: [&quot;chw_pump_2&quot;, &quot;ct_2&quot;]
      device_role: backup

  pumps:
    - id: chw_pump_1
      type: chilled_water
      max_hz: 60
      min_hz: 30
      efficiency_curve: &quot;pump_curve_1.json&quot;  # 僅作為物理約束參考，非預測模型

  cooling_towers:
    - id: ct_1
      type: induced_draft
      capacity_kw: 1500
      fan_speed_min: 30  # %
      fan_speed_max: 100

# 特徵映射設定（v1.1 新增：對應 Model Training 的特徵名稱）
feature_mapping:
  # 定義設備變數如何映射到模型特徵名稱
  # 若為空，預設使用 {device_id}_{parameter} 格式
  mappings:
    chiller_1_on: &quot;chiller_1_status&quot;
    chiller_1_load_percent: &quot;chiller_1_load_ratio&quot;
    chw_pump_1_hz: &quot;chw_pump_1_frequency&quot;
    wet_bulb_temp: &quot;ambient_wb_temp&quot;

# 邏輯約束定義（Logic Constraints）
logic_constraints:
  # 互鎖約束（Interlock）
  - type: requires
    if: &quot;chiller_1_on&quot;
    then: [&quot;chw_pump_1_on&quot;, &quot;ct_1_on&quot;]

  - type: requires
    if: &quot;chiller_2_on&quot;
    then: [&quot;chw_pump_2_on&quot;, &quot;ct_2_on&quot;]

  # 互斥約束（Mutual Exclusion）- 可選
  - type: mutex
    devices: [&quot;chiller_1&quot;, &quot;chiller_2&quot;]
    reason: &quot;電力容量限制，不可同時滿載&quot;

  # 順序約束（Sequence）- 開機順序
  - type: sequence
    startup: [&quot;ct_1&quot;, &quot;chw_pump_1&quot;, &quot;chiller_1&quot;]
    shutdown: [&quot;chiller_1&quot;, &quot;chw_pump_1&quot;, &quot;ct_1&quot;]

  # 運行時間約束（v1.1 新增：對應審查報告 3.3 建議）
  - type: min_runtime
    device: &quot;chiller_1&quot;
    minutes: 30  # 最小運行 30 分鐘，防止頻繁啟停

  - type: min_downtime
    device: &quot;chiller_1&quot;
    minutes: 15  # 最小停機 15 分鐘

# 優化參數
optimization:
  algorithm: &quot;differential_evolution&quot;  # 或 &quot;slsqp&quot;（僅連續變數）
  max_iter: 1000
  population_size: 50  # 遺傳演算法參數
  constraint_tolerance: 0.01

  # 切換懲罰（v1.1 新增：防止頻繁啟停）
  switching_penalty_kw: 5.0  # 每次狀態切換增加 5kW 等效成本

  # 目標函數權重（多目標時使用）
  objectives:
    - name: &quot;total_kw&quot;
      weight: 0.7
    - name: &quot;equipment_wear&quot;
      weight: 0.3  # 設備磨耗懲罰（減少頻繁啟停）

# 物理限制（可覆寫 Annotation 的值，但建議保持一致）
physical_constraints:
  chiller_out_temp:
    min: 6.5  # °C，覆寫 Annotation 若存在
    max: 8.0
</code></pre>
<h3 id="32-constraint-engine">3.2 約束引擎（Constraint Engine）</h3>
<p><strong>檔案</strong>: <code>src/optimization/constraints.py</code></p>
<p><strong>核心類別</strong>：</p>
<pre><code class="language-python">class ConstraintEngine:
    &quot;&quot;&quot;
    統一約束管理器
    整合物理限制（來自 Annotation）與邏輯約束（來自 Config）
    &quot;&quot;&quot;

    def __init__(self, site_config: OptimizationConfig, annotation_manager: FeatureAnnotationManager):
        self.physical_limits = self._load_physical_limits(annotation_manager)
        self.logic_constraints = LogicConstraintGraph(site_config.logic_constraints)
        self.equipment_specs = site_config.equipment
        self.switching_penalty = site_config.optimization.switching_penalty_kw  # v1.1 新增

    def validate_configuration(self, config: Dict) -&gt; Tuple[bool, List[str]]:
        &quot;&quot;&quot;
        驗證給定配置是否滿足所有硬約束
        回傳: (是否可行, 違反的約束列表)
        &quot;&quot;&quot;
        violations = []

        # 1. 邏輯約束檢查
        if not self.logic_constraints.check(config):
            violations.extend(self.logic_constraints.get_violations())

        # 2. 物理限制檢查
        for device_id, params in config.items():
            limits = self.physical_limits.get(device_id, {})
            if not self._check_limits(params, limits):
                violations.append(f&quot;Physical limit violated: {device_id}&quot;)

        # 3. 設備規格檢查（載率、頻率範圍）
        for eq_type, devices in self.equipment_specs.items():
            for device in devices:
                if not self._check_equipment_spec(config, device):
                    violations.append(f&quot;Equipment spec violated: {device.id}&quot;)

        # 4. 運行時間約束檢查（v1.1 新增）
        if not self._check_runtime_constraints(config):
            violations.append(&quot;Runtime constraint violated: min_runtime/min_downtime&quot;)

        return len(violations) == 0, violations

    def calculate_switching_cost(self, prev_config: Dict, new_config: Dict) -&gt; float:
        &quot;&quot;&quot;
        計算狀態切換懲罰（v1.1 新增）
        用於在目標函數中懲罰頻繁啟停
        &quot;&quot;&quot;
        switches = 0
        for key in prev_config:
            if key.endswith('_on') and prev_config.get(key) != new_config.get(key):
                switches += 1
        return switches * self.switching_penalty

    def get_feasible_regions(self, target_rt: float) -&gt; List[Dict]:
        &quot;&quot;&quot;
        預篩選：給定目標 RT，找出所有可行的設備組合（離散變數枚舉）
        回傳: 可行的設備啟停組合列表（連續變數尚未決定）
        &quot;&quot;&quot;
        # 使用 MIP 或簡單枚舉（若設備數量少）
        pass
</code></pre>
<p><strong>邏輯約束圖（LogicConstraintGraph）</strong>：</p>
<pre><code class="language-python">class LogicConstraintGraph:
    &quot;&quot;&quot;
    設備依賴關係圖
    支援 requires, mutex, sequence, min_runtime, min_downtime 五種約束
    &quot;&quot;&quot;

    def __init__(self, constraints: List[Dict]):
        self.graph = nx.DiGraph()  # NetworkX
        self.mutex_groups = []
        self.sequences = {}
        self.runtime_constraints = {}  # v1.1 新增：運行時間約束

        for c in constraints:
            if c['type'] == 'requires':
                self.graph.add_edge(c['if'], c['then'])
            elif c['type'] == 'mutex':
                self.mutex_groups.append(set(c['devices']))
            elif c['type'] == 'sequence':
                self.sequences[c['startup']] = c.get('shutdown', [])
            elif c['type'] in ['min_runtime', 'min_downtime']:  # v1.1 新增
                device = c['device']
                if device not in self.runtime_constraints:
                    self.runtime_constraints[device] = {}
                self.runtime_constraints[device][c['type']] = c['minutes']

    def check(self, config: Dict, runtime_history: Optional[Dict] = None) -&gt; bool:
        &quot;&quot;&quot;
        檢查邏輯約束
        runtime_history: 設備運行歷史（用於檢查 min_runtime/min_downtime）
        &quot;&quot;&quot;
        # 檢查 requires：若 if 為 True，則 then 必須都為 True
        # 檢查 mutex：同一組內不可同時為 True（或根據容量限制）
        # 檢查 sequence：開關機順序（若提供歷史資料）
        # 檢查 runtime：若 runtime_history 提供，驗證運行/停機時間
        pass
</code></pre>
<hr />
<h2 id="4-phase-based-implementation">4. 分階段實作計畫 (Phase-Based Implementation)</h2>
<h3 id="phase-0-day-1">Phase 0: 模型載入與相容性驗證 (Day 1)</h3>
<p><strong>Step 0.1: ModelRegistry 實作（v1.1 重大更新）</strong></p>
<pre><code class="language-python">class ModelRegistry:
    &quot;&quot;&quot;
    模型註冊表：載入與驗證 Model Training v1.2 輸出
    統一透過 model_registry_index.json 作為單一入口
    &quot;&quot;&quot;

    def __init__(self, models_dir: str = &quot;models&quot;):
        self.models_dir = Path(models_dir)
        self.logger = logging.getLogger(__name__)
        self._cache = {}  # 快取載入的模型

    def load_from_registry(
        self, 
        site_id: str, 
        target_id: str = &quot;system_total_kw&quot;,
        pinned_timestamp: Optional[str] = None
    ) -&gt; MultiModelArtifact:
        &quot;&quot;&quot;
        從 Model Registry Index 載入指定模型

        流程：
        1. 讀取 models/{site_id}/model_registry_index.json
        2. 驗證 schema_version &gt;= 1.2（E801）
        3. 比對 annotation_checksum（E802）
        4. 尋找 target_id（E804）
        5. 載入 MultiModelArtifact
        &quot;&quot;&quot;
        index_path = self.models_dir / site_id / &quot;model_registry_index.json&quot;

        if not index_path.exists():
            raise OptimizationError(&quot;E801&quot;, f&quot;Model Registry Index 不存在: {index_path}&quot;)

        with open(index_path, 'r') as f:
            index = json.load(f)

        # 驗證版本
        if index.get('schema_version') != '1.2':
            self.logger.warning(f&quot;Registry 版本 {index.get('schema_version')} 非預期 1.2&quot;)

        # 驗證 Annotation Checksum（關鍵檢查點）
        current_checksum = self._get_current_annotation_checksum(site_id)
        if index.get('annotation_checksum') != current_checksum:
            raise OptimizationError(
                &quot;E802&quot;, 
                f&quot;Annotation checksum 不匹配。模型訓練時: {index.get('annotation_checksum')}, &quot;
                f&quot;當前: {current_checksum}。請重新訓練模型或更新 Annotation。&quot;
            )

        # 尋找目標模型
        available = index.get('available_models', {})
        if target_id not in available:
            raise OptimizationError(
                &quot;E804&quot;, 
                f&quot;目標模型 {target_id} 不可用。可用目標: {list(available.keys())}&quot;
            )

        model_entry = available[target_id]

        # 版本控制（v1.1 新增）
        if pinned_timestamp:
            # 尋找特定版本
            manifest_pattern = f&quot;{target_id}/{pinned_timestamp}_ensemble_manifest.json&quot;
            manifest_path = self.models_dir / site_id / manifest_pattern
            if not manifest_path.exists():
                raise OptimizationError(&quot;E801&quot;, f&quot;指定的模型版本不存在: {manifest_pattern}&quot;)
        else:
            # 使用最新版本（根據 index 中的 path）
            manifest_path = self.models_dir / site_id / model_entry['path']

        # 載入 MultiModelArtifact
        return MultiModelArtifact.load(manifest_path)

    def get_feature_names(self, site_id: str, target_id: str = &quot;system_total_kw&quot;) -&gt; List[str]:
        &quot;&quot;&quot;
        取得模型預期的特徵名稱列表（供 FeatureVectorizer 使用）
        用於驗證 E803（特徵維度對齊）
        &quot;&quot;&quot;
        # 從 index 或 manifest 讀取 feature_names（若 Training v1.2 提供）
        pass

    def validate_hybrid_consistency(
        self, 
        site_id: str,
        config: Dict, 
        ambient: Dict,
        tolerance: float = 0.05
    ) -&gt; Tuple[bool, Dict]:
        &quot;&quot;&quot;
        Hybrid 模式一致性檢查（v1.1 新增）
        比較 System Model 預測與 Component Models 加總
        &quot;&quot;&quot;
        try:
            system_artifact = self.load_from_registry(site_id, &quot;system_total_kw&quot;)
            system_pred = system_artifact.predict(config, ambient)

            # 嘗試載入各 component models
            component_sum = 0
            components = {}
            for i in range(1, 5):  # 假設最多 4 台主機
                try:
                    chiller_art = self.load_from_registry(site_id, f&quot;chiller_{i}_kw&quot;)
                    pred = chiller_art.predict(config, ambient)
                    component_sum += pred
                    components[f&quot;chiller_{i}_kw&quot;] = pred
                except OptimizationError:
                    continue

            discrepancy = abs(system_pred - component_sum) / system_pred if system_pred &gt; 0 else 0

            return discrepancy &lt;= tolerance, {
                &quot;system_prediction&quot;: system_pred,
                &quot;component_sum&quot;: component_sum,
                &quot;discrepancy_percent&quot;: discrepancy * 100,
                &quot;components&quot;: components,
                &quot;within_tolerance&quot;: discrepancy &lt;= tolerance
            }

        except Exception as e:
            return False, {&quot;error&quot;: str(e)}
</code></pre>
<p><strong>Step 0.2: FeatureVectorizer 實作（v1.1 新增）</strong></p>
<pre><code class="language-python">class FeatureVectorizer:
    &quot;&quot;&quot;
    將 Optimization 配置轉換為模型特徵向量
    確保與 Training v1.2 的特徵工程一致
    &quot;&quot;&quot;

    def __init__(self, site_config: OptimizationConfig, model_features: List[str]):
        self.model_features = model_features
        self.feature_mapping = site_config.feature_mapping.get('mappings', {})
        self.scaler = self._load_scaler(site_config)  # 載入訓練時的 StandardScaler

    def vectorize(
        self, 
        discrete_vars: Dict[str, bool],
        continuous_vars: Dict[str, float],
        ambient: Dict[str, float]
    ) -&gt; np.ndarray:
        &quot;&quot;&quot;
        轉換流程：
        1. 合併所有變數
        2. 套用特徵名稱映射（若 config 中有定義）
        3. 依照 model_features 順序排列
        4. 套用縮放（若需要）
        &quot;&quot;&quot;
        # 合併變數
        features = {}

        # 處理離散變數（bool → float）
        for key, value in discrete_vars.items():
            mapped_key = self.feature_mapping.get(key, key)
            features[mapped_key] = 1.0 if value else 0.0

        # 處理連續變數（單位轉換）
        for key, value in continuous_vars.items():
            mapped_key = self.feature_mapping.get(key, key)
            # 轉換邏輯：例如 load_percent 從 % 轉為 ratio
            if 'percent' in key and 'ratio' in mapped_key:
                value = value / 100.0
            features[mapped_key] = value

        # 處理環境變數
        for key, value in ambient.items():
            mapped_key = self.feature_mapping.get(key, key)
            features[mapped_key] = value

        # 依照 model_features 順序建立向量
        vector = np.array([features.get(f, 0.0) for f in self.model_features])

        # 套用縮放
        if self.scaler:
            vector = self.scaler.transform(vector.reshape(1, -1))[0]

        return vector

    def validate_alignment(self, site_config: OptimizationConfig) -&gt; Tuple[bool, List[str]]:
        &quot;&quot;&quot;
        驗證 E803：檢查是否能產生所有必要的特徵
        回傳: (是否對齊, 缺少的特徵列表)
        &quot;&quot;&quot;
        # 檢查必要特徵是否存在對應
        missing = []
        for feat in self.model_features:
            if feat not in self.feature_mapping.values():
                # 檢查是否可從設備配置推導
                if not self._can_derive(feat, site_config):
                    missing.append(feat)

        return len(missing) == 0, missing
</code></pre>
<p><strong>錯誤碼定義（與 Training v1.2 對齊）</strong>：</p>
<pre><code class="language-python">class OptimizationError(Exception):
    ERROR_CODES = {
        &quot;E801&quot;: &quot;MODEL_REGISTRY_ERROR - 無法載入 Model Registry Index 或模型檔案&quot;,
        &quot;E802&quot;: &quot;ANNOTATION_VERSION_MISMATCH - 模型訓練時的 Annotation checksum 與當前不符&quot;,
        &quot;E803&quot;: &quot;FEATURE_DIMENSION_MISMATCH - 特徵數量或名稱與模型預期不符&quot;,
        &quot;E804&quot;: &quot;TARGET_NOT_AVAILABLE - 請求的 target_id（如 system_total_kw）在 Registry 中不存在&quot;,
        &quot;E805&quot;: &quot;HYBRID_INCONSISTENCY - Component Models 加總與 System Model 預測差異過大（&gt;5%）&quot;,
        # ... 其他原有錯誤碼
    }
</code></pre>
<h3 id="phase-1-day-2-3">Phase 1: 約束引擎與可行解空間 (Day 2-3)</h3>
<p><strong>Step 1.1: 物理限制載入</strong><br />
- 從 <code>FeatureAnnotationManager</code> 讀取 <code>physical_types</code> 的 <code>valid_range</code><br />
- 與 Optimization Config 中的 <code>physical_constraints</code> 合併（Config 優先）</p>
<p><strong>Step 1.2: 邏輯約束引擎（含 v1.1 新增）</strong><br />
- 實作 <code>LogicConstraintGraph</code>，支援 requires/mutex/sequence/min_runtime/min_downtime<br />
- 實作 <code>get_feasible_combinations()</code>：枚舉所有滿足邏輯約束的設備啟停組合<br />
- <strong>新增</strong>：<code>calculate_switching_penalty()</code> 計算狀態切換懲罰</p>
<p><strong>Step 1.3: 可行解預篩選</strong></p>
<pre><code class="language-python">def enumerate_feasible_combinations(target_rt: float, site_config: OptimizationConfig) -&gt; List[Dict]:
    &quot;&quot;&quot;
    給定目標 RT，找出所有可行的設備啟停組合
    策略：
    1. 計算需要的總容量（target_rt / 總可用容量）
    2. 枚舉所有組合（若設備數 &lt;= 8，可用窮舉；否則用啟發式）
    3. 用邏輯約束過濾（requires, mutex, sequence）
    4. 用物理限制過濾（如最低載率）
    5. 用運行時間約束過濾（若提供歷史狀態）
    &quot;&quot;&quot;
    pass
</code></pre>
<h3 id="phase-2-day-3-4">Phase 2: 最佳化核心 (Day 3-4)</h3>
<p><strong>Step 2.1: 目標函數封裝（v1.1 更新）</strong></p>
<pre><code class="language-python">class ObjectiveFunction:
    &quot;&quot;&quot;
    支援兩種模式的目标函数（v1.1 更新：整合切換懲罰）
    &quot;&quot;&quot;

    def __init__(
        self, 
        mode: str, 
        target_value: float, 
        model_registry: ModelRegistry,
        constraint_engine: ConstraintEngine,
        vectorizer: FeatureVectorizer
    ):
        self.mode = mode
        self.target = target_value
        self.models = model_registry
        self.constraints = constraint_engine
        self.vectorizer = vectorizer
        self.prev_config = None  # 用於計算切換懲罰

    def evaluate(
        self, 
        continuous_vars: Dict, 
        discrete_vars: Dict, 
        ambient: Dict
    ) -&gt; float:
        &quot;&quot;&quot;
        回傳損失值（越小越好）
        v1.1 更新：
        - 使用 FeatureVectorizer 轉換特徵
        - 加入切換懲罰（switching_penalty）
        - 支援預測區間（若使用 RF）
        &quot;&quot;&quot;
        config = {**discrete_vars, **continuous_vars}

        # 特徵向量化
        feature_vector = self.vectorizer.vectorize(discrete_vars, continuous_vars, ambient)

        # 取得預測（透過 ModelRegistry）
        prediction_result = self.models.predict_with_interval(
            feature_vector, 
            target_id=&quot;system_total_kw&quot;
        )
        predicted_kw = prediction_result['prediction']

        # 計算基礎損失
        if self.mode == &quot;load_driven&quot;:
            # 目標：滿足 RT 的前提下，最小化 kW
            predicted_rt = self._calculate_rt(discrete_vars, continuous_vars)  # 基於設備容量計算
            rt_penalty = max(0, self.target - predicted_rt) ** 2 * 1000
            base_loss = predicted_kw + rt_penalty

        elif self.mode == &quot;efficiency_driven&quot;:
            # 目標：達到 target kW/RT，最小化與目標的差距
            predicted_rt = self._calculate_rt(discrete_vars, continuous_vars)
            actual_kw_rt = predicted_kw / predicted_rt if predicted_rt &gt; 0 else float('inf')
            base_loss = (actual_kw_rt - self.target) ** 2

        # v1.1 新增：切換懲罰
        switching_cost = 0
        if self.prev_config:
            switching_cost = self.constraints.calculate_switching_cost(
                self.prev_config, config
            )

        return base_loss + switching_cost
</code></pre>
<p><strong>Step 2.2: 混合優化策略</strong></p>
<p>採用<strong>兩階段策略</strong>（與 v1.0 相同，但使用更新後的目標函數）：</p>
<pre><code class="language-python">class HybridOptimizer:
    &quot;&quot;&quot;
    混合整數規劃 + 連續優化（v1.1 更新：整合 ModelRegistry）
    &quot;&quot;&quot;

    def __init__(self, model_registry: ModelRegistry, constraint_engine: ConstraintEngine):
        self.model_registry = model_registry
        self.constraint_engine = constraint_engine

    def optimize(self, request: OptimizationRequest) -&gt; OptimizationResponse:
        # Phase 1：枚舉所有可行的設備組合（離散變數）
        feasible_combos = self.constraint_engine.get_feasible_combinations(request.target_rt)

        # 初始化 FeatureVectorizer（v1.1 新增）
        model_features = self.model_registry.get_feature_names(
            request.site_id, 
            target_id=&quot;system_total_kw&quot;
        )
        vectorizer = FeatureVectorizer(self.site_config, model_features)

        # 驗證特徵對齊（E803 檢查）
        is_aligned, missing = vectorizer.validate_alignment(self.site_config)
        if not is_aligned:
            raise OptimizationError(
                &quot;E803&quot;, 
                f&quot;特徵對齊失敗，缺少特徵: {missing}&quot;
            )

        best_result = None
        best_score = float('inf')

        # Phase 2：對每個組合，優化連續變數（頻率、轉速）
        for combo in feasible_combos:
            result = self._optimize_continuous(combo, request, vectorizer)

            if result.score &lt; best_score:
                best_score = result.score
                best_result = result

        # Hybrid 一致性檢查（若啟用）
        hybrid_check = None
        if self.site_config.model_registry.fallback_to_components:
            is_consistent, check_data = self.model_registry.validate_hybrid_consistency(
                request.site_id,
                best_result.config,
                request.ambient_conditions
            )
            hybrid_check = check_data

        return self._build_response(best_result, request, hybrid_check)

    def _optimize_continuous(
        self, 
        discrete_combo: Dict, 
        request: OptimizationRequest,
        vectorizer: FeatureVectorizer
    ):
        &quot;&quot;&quot;
        對固定設備組合，優化連續參數（v1.1 更新：使用 ModelRegistry 預測）
        &quot;&quot;&quot;
        from scipy.optimize import differential_evolution

        # 定義目標函數（封裝 ModelRegistry 呼叫）
        obj_func = ObjectiveFunction(
            mode=request.mode,
            target_value=request.target_rt or request.target_kw_per_rt,
            model_registry=self.model_registry,
            constraint_engine=self.constraint_engine,
            vectorizer=vectorizer
        )

        def objective(x):
            continuous_vars = self._unpack_variables(x)
            return obj_func.evaluate(continuous_vars, discrete_combo, request.ambient_conditions)

        # 執行優化（略，與 v1.0 相同）
        result = differential_evolution(objective, bounds, ...)
        return result
</code></pre>
<h3 id="phase-3-day-4-5">Phase 3: 報告生成與節能評估 (Day 4-5)</h3>
<p><strong>Step 3.1: 改善前後比較邏輯（v1.1 更新）</strong></p>
<pre><code class="language-python">class SavingsCalculator:
    &quot;&quot;&quot;
    計算節能量與改善評估（v1.1 更新：使用 ModelRegistry）
    &quot;&quot;&quot;

    def calculate(
        self, 
        recommended: Dict, 
        current: Optional[Dict], 
        ambient: Dict,
        site_id: str,
        operating_hours: int = 8760
    ) -&gt; Dict:
        &quot;&quot;&quot;
        回傳：
        - 當前能耗（使用 system_total_kw 模型預測）
        - 建議能耗
        - 節省 kW、kWh/年、百分比
        - CO2 減排量
        - Hybrid 模式下的耗電佔比分解（若可用）
        &quot;&quot;&quot;
        # 載入 System-Level 模型（唯一真相來源）
        system_artifact = self.model_registry.load_from_registry(site_id, &quot;system_total_kw&quot;)

        # 預測 baseline（當前配置）
        if current:
            baseline_kw = system_artifact.predict(current, ambient)
        else:
            baseline_kw = self._calculate_baseline(recommended['target_rt'])

        # 預測建議配置
        recommended_kw = system_artifact.predict(recommended, ambient)

        # Hybrid 分解（選用）
        component_breakdown = None
        if self.model_registry.config.fallback_to_components:
            component_breakdown = self._get_component_breakdown(site_id, recommended, ambient)

        # 計算節能指標（略，與 v1.0 相同）
        savings_kw = baseline_kw - recommended_kw
        savings_percent = (savings_kw / baseline_kw) * 100 if baseline_kw &gt; 0 else 0

        return {
            'baseline_kw': baseline_kw,
            'recommended_kw': recommended_kw,
            'savings_kw': savings_kw,
            'savings_percent': savings_percent,
            'annual_savings_kwh': savings_kw * operating_hours,
            'co2_reduction_tons': savings_kw * operating_hours * 0.0005,
            'component_breakdown': component_breakdown  # v1.1 新增
        }

    def _get_component_breakdown(
        self, 
        site_id: str, 
        config: Dict, 
        ambient: Dict
    ) -&gt; Optional[Dict[str, float]]:
        &quot;&quot;&quot;
        使用 Component Models 分解耗電佔比（v1.1 新增）
        &quot;&quot;&quot;
        breakdown = {}
        try:
            for i in range(1, 5):
                try:
                    art = self.model_registry.load_from_registry(site_id, f&quot;chiller_{i}_kw&quot;)
                    breakdown[f&quot;chiller_{i}_kw&quot;] = art.predict(config, ambient)
                except:
                    continue
            # 類似處理 pumps, towers...
            return breakdown
        except:
            return None
</code></pre>
<p><strong>Step 3.2: 報告生成器（v1.1 更新：增加模型資訊與 Hybrid 檢查）</strong></p>
<pre><code class="language-python">class OptimizationReportGenerator:
    &quot;&quot;&quot;
    生成工程師可讀的優化報告（v1.1 更新）
    &quot;&quot;&quot;

    def generate(
        self, 
        response: OptimizationResponse, 
        request: OptimizationRequest
    ) -&gt; str:
        &quot;&quot;&quot;
        產生 Markdown 格式報告，包含：
        - 使用的模型版本資訊
        - Hybrid 一致性檢查結果（若適用）
        - 耗電佔比分解（若可用）
        &quot;&quot;&quot;
        report = f&quot;&quot;&quot;
# 冰水主機房最佳化建議報告

## 案場資訊
- 案場 ID：{request.site_id}
- 優化模式：{'負載驅動' if request.mode == 'load_driven' else '效率驅動'}
- 目標值：{request.target_rt or request.target_kw_per_rt} {'RT' if request.mode == 'load_driven' else 'kW/RT'}
- 分析時間：{datetime.now().isoformat()}

## 模型資訊（v1.1 新增）
- 使用模型：{response.model_used}
- 模型版本：{response.model_timestamp}
- 預測信心區間：{response.prediction_interval or '未提供'}

## 建議配置
...

## 能耗評估
...

## Hybrid 一致性檢查（v1.1 新增，若適用）
&quot;&quot;&quot;
        if response.hybrid_consistency_check:
            check = response.hybrid_consistency_check
            report += f&quot;&quot;&quot;
- 系統模型預測：{check['system_prediction']:.1f} kW
- 組件加總預測：{check['component_sum']:.1f} kW
- 差異率：{check['discrepancy_percent']:.2f}%
- 狀態：{'通過' if check['within_tolerance'] else '警告（差異 &gt;5%）'}
&quot;&quot;&quot;
        return report
</code></pre>
<h3 id="phase-4-cli-day-5-6">Phase 4: CLI 與多案場支援 (Day 5-6)</h3>
<p><strong>Step 4.1: OptimizationCLI（v1.1 更新）</strong></p>
<pre><code class="language-python">class OptimizationCLI:
    &quot;&quot;&quot;
    命令列介面（v1.1 更新：支援 Model Registry 與環境檔案）
    &quot;&quot;&quot;

    def optimize(
        self, 
        site: str, 
        mode: str, 
        target: float,
        model_target: str = &quot;system_total_kw&quot;,  # v1.1 新增：指定使用哪個 target
        ambient_file: Optional[str] = None,      # v1.1 新增：環境資料檔案
        pinned_timestamp: Optional[str] = None,  # v1.1 新增：鎖定模型版本
        output_format: str = &quot;markdown&quot;
    ):
        &quot;&quot;&quot;
        CLI 指令範例：

        # 基本使用（使用最新 system_total_kw 模型）
        python main.py optimization optimize \
            --site cgmh_ty \
            --mode load_driven \
            --target 500 \
            --output report.md

        # 使用特定模型版本並提供環境資料
        python main.py optimization optimize \
            --site cgmh_ty \
            --mode load_driven \
            --target 500 \
            --model-target system_total_kw \
            --pinned-timestamp 20260213_120000 \
            --ambient-file weather_202502.csv \
            --output report.md
        &quot;&quot;&quot;
        pass

    def batch_scenarios(
        self, 
        site: str, 
        rt_range: str, 
        step: float,
        ambient_file: str  # v1.1 新增：批次分析必須提供環境資料
    ):
        &quot;&quot;&quot;
        批次分析多個負載情境
        python main.py optimization batch-scenarios \
            --site cgmh_ty \
            --rt-range 100-1000 \
            --step 100 \
            --ambient-file weather_year_2024.csv
        &quot;&quot;&quot;
        pass
</code></pre>
<p><strong>Step 4.2: 多案場配置繼承（與 v1.0 相同，略）</strong></p>
<hr />
<h2 id="5-error-codes-v11">5. 錯誤代碼對照表 (Error Codes) - v1.1 更新</h2>
<p>與 Model Training v1.2 對齊的錯誤碼體系：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">錯誤代碼</th>
<th style="text-align: left;">名稱</th>
<th style="text-align: center;">發生階段</th>
<th style="text-align: left;">說明</th>
<th style="text-align: left;">處理建議</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>E800</strong></td>
<td style="text-align: left;"><code>CONFIG_VALIDATION_ERROR</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">Optimization Config YAML 格式錯誤</td>
<td style="text-align: left;">檢查 config/optimization/sites/{site}.yaml</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E801</strong></td>
<td style="text-align: left;"><code>MODEL_REGISTRY_NOT_FOUND</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">找不到 model_registry_index.json 或模型檔案</td>
<td style="text-align: left;">確認模型訓練已完成（Training v1.2+），檔案路徑正確</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E802</strong></td>
<td style="text-align: left;"><code>ANNOTATION_CHECKSUM_MISMATCH</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">模型訓練時的 Annotation checksum 與當前不符</td>
<td style="text-align: left;">Feature Annotation 已更新，需重新訓練模型</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E803</strong></td>
<td style="text-align: left;"><code>FEATURE_DIMENSION_MISMATCH</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">Optimization Config 特徵數與 ModelEntry.feature_count 不符，或特徵名稱無法對齊</td>
<td style="text-align: left;">檢查 feature_mapping 設定或重新訓練模型</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E804</strong></td>
<td style="text-align: left;"><code>TARGET_NOT_AVAILABLE</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">請求的 target_id（如 system_total_kw）在 Registry 中不存在或標記為 optional</td>
<td style="text-align: left;">確認 Training Pipeline 已訓練該 target</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E805</strong></td>
<td style="text-align: left;"><code>HYBRID_INCONSISTENCY</code></td>
<td style="text-align: center;">Phase 2</td>
<td style="text-align: left;">Component Models 加總與 System Model 預測差異 &gt;5%</td>
<td style="text-align: left;">警告：檢查特徵工程或改用純 System-Level</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E806</strong></td>
<td style="text-align: left;"><code>OPTIMIZATION_TIMEOUT</code></td>
<td style="text-align: center;">Phase 2</td>
<td style="text-align: left;">優化算法超時未收斂</td>
<td style="text-align: left;">增加 max_iter 或改用啟發式算法</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E807</strong></td>
<td style="text-align: left;"><code>RT_NOT_ACHIEVABLE</code></td>
<td style="text-align: center;">Phase 2</td>
<td style="text-align: left;">無法達到目標冷凍噸（設備容量不足）</td>
<td style="text-align: left;">檢查目標 RT 是否超過總裝置容量</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E808</strong></td>
<td style="text-align: left;"><code>EFFICIENCY_NOT_ACHIEVABLE</code></td>
<td style="text-align: center;">Phase 2</td>
<td style="text-align: left;">無法達到目標 kW/RT（可能過於激進）</td>
<td style="text-align: left;">檢查目標效率是否低於理論最小值</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E809</strong></td>
<td style="text-align: left;"><code>LOGIC_CONSTRAINT_VIOLATION</code></td>
<td style="text-align: center;">Phase 1</td>
<td style="text-align: left;">建議配置違反邏輯約束（如開主機未開泵）</td>
<td style="text-align: left;">內部錯誤，檢查 ConstraintEngine</td>
</tr>
<tr>
<td style="text-align: left;"><strong>W801</strong></td>
<td style="text-align: left;"><code>SOFT_CONSTRAINT_VIOLATED</code></td>
<td style="text-align: center;">Phase 2</td>
<td style="text-align: left;">違反軟約束（如建議開啟備用機組）</td>
<td style="text-align: left;">建議接受，但記錄偏好衝突</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E901</strong></td>
<td style="text-align: left;"><code>MULTI_TARGET_ANNOTATION_MISMATCH</code></td>
<td style="text-align: center;">Training</td>
<td style="text-align: left;">多目標訓練時 Annotation Context 不一致</td>
<td style="text-align: left;">引用 Training v1.2 錯誤碼</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E903</strong></td>
<td style="text-align: left;"><code>HYBRID_CONSISTENCY_VIOLATION</code></td>
<td style="text-align: center;">Training</td>
<td style="text-align: left;">Hybrid 模式下 Component 加總與 System 預測差異過大</td>
<td style="text-align: left;">引用 Training v1.2 錯誤碼</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="6-version-compatibility-v11">6. 版本相容性矩陣 (Version Compatibility) - v1.1 更新</h2>
<table>
<thead>
<tr>
<th style="text-align: center;">Model Training</th>
<th style="text-align: center;">Feature Annotation</th>
<th style="text-align: center;">Optimization Engine</th>
<th style="text-align: center;">相容性</th>
<th style="text-align: left;">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>v1.2</strong></td>
<td style="text-align: center;">v1.2</td>
<td style="text-align: center;"><strong>v1.1</strong></td>
<td style="text-align: center;">✅ <strong>完全相容</strong></td>
<td style="text-align: left;">推薦配置，透過 Model Registry Index 載入，支援 System/Component/Hybrid</td>
</tr>
<tr>
<td style="text-align: center;">v1.2</td>
<td style="text-align: center;">v1.2</td>
<td style="text-align: center;">v1.0</td>
<td style="text-align: center;">⚠️ <strong>部分相容</strong></td>
<td style="text-align: left;">需手動指定模型路徑，無 Registry Index 支援</td>
</tr>
<tr>
<td style="text-align: center;">v1.1</td>
<td style="text-align: center;">v1.2</td>
<td style="text-align: center;"><strong>v1.1</strong></td>
<td style="text-align: center;">⚠️ <strong>部分相容</strong></td>
<td style="text-align: left;">需手動指定模型路徑，無 Index 自動發現</td>
</tr>
<tr>
<td style="text-align: center;">v1.0</td>
<td style="text-align: center;">任意</td>
<td style="text-align: center;"><strong>v1.1</strong></td>
<td style="text-align: center;">❌ <strong>不相容</strong></td>
<td style="text-align: left;">輸出格式不同，無法載入</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="7-test-plan-v11">7. 測試與驗證計畫 (Test Plan) - v1.1 更新</h2>
<h3 id="71">7.1 單元測試</h3>
<table>
<thead>
<tr>
<th style="text-align: left;">測試案例 ID</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">輸入</th>
<th style="text-align: left;">預期結果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">OPT-001</td>
<td style="text-align: left;">邏輯約束驗證</td>
<td style="text-align: left;">chiller_1_on=True, chw_pump_1_on=False</td>
<td style="text-align: left;">違反 requires 約束，回傳 False</td>
</tr>
<tr>
<td style="text-align: left;">OPT-002</td>
<td style="text-align: left;">可行組合枚舉</td>
<td style="text-align: left;">target_rt=500, 2台主機各300RT</td>
<td style="text-align: left;">回傳：[開1台+載率83%], [開2台+各載率42%]</td>
</tr>
<tr>
<td style="text-align: left;">OPT-003</td>
<td style="text-align: left;">負載驅動優化</td>
<td style="text-align: left;">target_rt=400, ambient=30°C</td>
<td style="text-align: left;">選擇效率最佳的設備組合與頻率</td>
</tr>
<tr>
<td style="text-align: left;">OPT-004</td>
<td style="text-align: left;">效率驅動優化</td>
<td style="text-align: left;">target_kw_per_rt=0.6</td>
<td style="text-align: left;">調整頻率與台數，使效率最接近0.6</td>
</tr>
<tr>
<td style="text-align: left;">OPT-005</td>
<td style="text-align: left;">節能計算</td>
<td style="text-align: left;">baseline=500kW, recommended=400kW</td>
<td style="text-align: left;">savings_kw=100, savings_percent=20%</td>
</tr>
<tr>
<td style="text-align: left;">OPT-006</td>
<td style="text-align: left;">繼承機制</td>
<td style="text-align: left;">cgmh_ty 繼承 base</td>
<td style="text-align: left;">正確合併 equipment 與 constraints</td>
</tr>
<tr>
<td style="text-align: left;"><strong>OPT-007</strong></td>
<td style="text-align: left;"><strong>Registry 載入</strong></td>
<td style="text-align: left;">site_id="cgmh_ty", target="system_total_kw"</td>
<td style="text-align: left;">正確載入 MultiModelArtifact，驗證 checksum</td>
</tr>
<tr>
<td style="text-align: left;"><strong>OPT-008</strong></td>
<td style="text-align: left;"><strong>特徵向量化</strong></td>
<td style="text-align: left;">discrete_vars + continuous_vars</td>
<td style="text-align: left;">產生與訓練時相同順序的特徵向量</td>
</tr>
<tr>
<td style="text-align: left;"><strong>OPT-009</strong></td>
<td style="text-align: left;"><strong>版本鎖定</strong></td>
<td style="text-align: left;">pinned_timestamp="20260213_120000"</td>
<td style="text-align: left;">載入指定版本，非最新版本</td>
</tr>
<tr>
<td style="text-align: left;"><strong>OPT-010</strong></td>
<td style="text-align: left;"><strong>Hybrid 一致性</strong></td>
<td style="text-align: left;">config 導致 system=300kW, components=280kW</td>
<td style="text-align: left;">觸發 E805 警告，但以 System 為準</td>
</tr>
</tbody>
</table>
<h3 id="72">7.2 整合測試</h3>
<table>
<thead>
<tr>
<th style="text-align: left;">測試案例 ID</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">驗證目標</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">INT-OPT-001</td>
<td style="text-align: left;">端到端優化流程</td>
<td style="text-align: left;">從 Request 到 Report 完整流程，使用 Registry Index</td>
</tr>
<tr>
<td style="text-align: left;">INT-OPT-002</td>
<td style="text-align: left;">多案場切換</td>
<td style="text-align: left;">切換 cgmh_ty 與 farglory_o3，Config 與 Model 正確載入</td>
</tr>
<tr>
<td style="text-align: left;">INT-OPT-003</td>
<td style="text-align: left;">與 Model Training v1.2 銜接</td>
<td style="text-align: left;">使用 Training v1.2 產出的 Registry Index 與 Artifacts</td>
</tr>
<tr>
<td style="text-align: left;"><strong>INT-OPT-004</strong></td>
<td style="text-align: left;"><strong>特徵對齊驗證</strong></td>
<td style="text-align: left;">驗證 FeatureVectorizer 輸出與 Model 預期一致（E803）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>INT-OPT-005</strong></td>
<td style="text-align: left;"><strong>環境資料批次輸入</strong></td>
<td style="text-align: left;">透過 --ambient-file 載入 CSV 進行全年模擬</td>
</tr>
<tr>
<td style="text-align: left;"><strong>INT-OPT-006</strong></td>
<td style="text-align: left;"><strong>模型版本鎖定</strong></td>
<td style="text-align: left;">指定 pinned_timestamp 確保重現性</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="8-deliverables-v11">8. 交付物清單 (Deliverables) - v1.1 更新</h2>
<h3 id="81">8.1 程式碼檔案</h3>
<ol>
<li><code>src/optimization/engine.py</code> - 最佳化主引擎（更新：整合 ModelRegistry）</li>
<li><code>src/optimization/constraints.py</code> - 約束引擎（更新：增加 runtime constraints）</li>
<li><code>src/optimization/scenarios.py</code> - 情境分析與批次處理</li>
<li><code>src/optimization/model_interface.py</code> - <strong>新增：ModelRegistry 與 FeatureVectorizer</strong></li>
<li><code>src/optimization/report.py</code> - 報告生成器（更新：增加模型資訊與 Hybrid 檢查）</li>
<li><code>src/optimization/config.py</code> - OptimizationConfig（更新：增加 model_registry 設定）</li>
</ol>
<h3 id="82">8.2 配置文件</h3>
<ol start="7">
<li><code>config/optimization/base.yaml</code> - 基礎設備模型與約束（更新：移除 model_file，增加 model_registry）</li>
<li><code>config/optimization/sites/cgmh_ty.yaml</code> - 長庚醫院範例（更新格式）</li>
<li><code>config/optimization/schemas/optimization_schema.json</code> - JSON Schema（更新驗證規則）</li>
</ol>
<h3 id="83">8.3 測試檔案</h3>
<ol start="10">
<li><code>tests/test_optimization_engine.py</code> - 引擎單元測試（更新）</li>
<li><code>tests/test_constraints.py</code> - 約束引擎測試（更新）</li>
<li><code>tests/test_model_interface.py</code> - <strong>新增：ModelRegistry 與 FeatureVectorizer 測試</strong></li>
<li><code>tests/test_optimization_integration.py</code> - 整合測試（更新）</li>
</ol>
<h3 id="84">8.4 文件檔案</h3>
<ol start="14">
<li><code>docs/optimization/PRD_OPTIMIZATION_ENGINE_v1.1.md</code> - 本文件</li>
<li><code>docs/optimization/USER_GUIDE.md</code> - 工程師使用手冊（含 Model Registry 使用說明）</li>
<li><code>docs/optimization/MIGRATION_v1.0_to_v1.1.md</code> - <strong>新增：v1.0 升級指南</strong></li>
</ol>
<hr />
<h2 id="9-sign-off-checklist-v11">9. 驗收簽核 (Sign-off Checklist) - v1.1 更新</h2>
<ul>
<li>[ ] <strong>Registry 載入</strong>：正確從 <code>model_registry_index.json</code> 載入模型，驗證 E801</li>
<li>[ ] <strong>版本綁定</strong>：驗證 <code>annotation_checksum</code>，正確拋出 E802</li>
<li>[ ] <strong>特徵對齊</strong>：FeatureVectorizer 正確轉換配置為特徵向量，驗證 E803</li>
<li>[ ] <strong>目標可用性</strong>：請求不存在的 target 時正確拋出 E804</li>
<li>[ ] <strong>Hybrid 檢查</strong>：Component 與 System 預測差異 &gt;5% 時觸發 E805 警告</li>
<li>[ ] <strong>系統級優化</strong>：預設使用 <code>system_total_kw</code> 進行優化（黑盒模式）</li>
<li>[ ] <strong>版本鎖定</strong>：支援 <code>pinned_timestamp</code> 鎖定特定模型版本</li>
<li>[ ] <strong>環境資料輸入</strong>：支援從 CSV 檔案讀取環境條件進行批次模擬</li>
<li>[ ] <strong>切換懲罰</strong>：目標函數正確計算設備啟停切換成本</li>
<li>[ ] <strong>運行時間約束</strong>：支援 <code>min_runtime</code> / <code>min_downtime</code> 約束檢查</li>
<li>[ ] <strong>負載驅動模式</strong>：給定 RT=500，輸出最佳設備組合（台數、頻率、轉速）</li>
<li>[ ] <strong>效率驅動模式</strong>：給定 kW/RT=0.65，反推設備參數，達成目標效率</li>
<li>[ ] <strong>可行解檢查</strong>：若目標 RT 超過總容量，正確拋出 E807</li>
<li>[ ] <strong>節能評估</strong>：正確計算改善前後差異、年節電量、減碳量</li>
<li>[ ] <strong>報告生成</strong>：產生工程師可讀的 Markdown 報告，包含模型版本與 Hybrid 檢查結果</li>
<li>[ ] <strong>多案場支援</strong>：支援 base.yaml → site.yaml 繼承，設備參數可覆寫</li>
<li>[ ] <strong>CLI 介面</strong>：<code>python main.py optimization optimize</code> 指令支援所有 v1.1 參數</li>
</ul>
<hr />
<h2 id="10">10. 附錄：使用範例</h2>
<h3 id="1_1">範例 1：負載驅動（使用預設最新模型）</h3>
<pre><code class="language-bash">python main.py optimization optimize \
    --site cgmh_ty \
    --mode load_driven \
    --target 500 \
    --ambient '{&quot;wet_bulb_temp&quot;: 26.5, &quot;dry_bulb_temp&quot;: 32.0}' \
    --output report_500rt.md
</code></pre>
<p><strong>預期輸出</strong>：</p>
<pre><code>模型資訊：使用 xgboost (20260213_120000)
建議開啟：Chiller 1 (Primary, 300RT) + Chiller 2 (Backup, 200RT)
載率分配：60% / 40%
冷凍水泵：45 Hz / 40 Hz
冷卻水塔：80% 轉速
預測總耗電：325 kW (0.65 kW/RT) [信心區間: 315-335 kW]
相較於全開基線 (400 kW)：節省 18.75%，年節電 657,000 kWh
</code></pre>
<h3 id="2">範例 2：效率驅動（鎖定模型版本並使用環境檔案）</h3>
<pre><code class="language-bash">python main.py optimization optimize \
    --site cgmh_ty \
    --mode efficiency_driven \
    --target 0.60 \
    --pinned-timestamp 20260213_120000 \
    --ambient-file summer_weather.csv \
    --current-config current_operation.json \
    --output report_efficiency.md
</code></pre>
<p><strong>預期輸出</strong>：</p>
<pre><code>模型版本：鎖定 20260213_120000 (xgboost)
環境資料：使用 summer_weather.csv (共 720 筆小時資料)
平均效率：當前 0.72 kW/RT → 建議 0.60 kW/RT
建議調整：
  1. 關閉 Chiller 2，僅使用 Chiller 1 (載率提升至 92%)
  2. 降低冷卻水塔轉速至 65%
  3. 調整冷凍水泵至 42 Hz
預期節省：平均 100 kW (25%)，夏季總節電 72,000 kWh

Hybrid 一致性檢查：
- 系統模型預測：300 kW
- 組件加總：295 kW (Chiller1: 200, Chiller2: 0, Pumps: 60, Towers: 35)
- 差異率：1.7% (通過)
</code></pre>
<h3 id="3_1">範例 3：批次情境分析（產生全年效率曲線）</h3>
<pre><code class="language-bash">python main.py optimization batch-scenarios \
    --site cgmh_ty \
    --rt-range 100-1000 \
    --step 50 \
    --ambient-file weather_2024_hourly.csv \
    --output annual_analysis.json
</code></pre>
<hr />
<p><strong>關鍵設計確認 (v1.1)</strong>:<br />
1. <strong>系統級黑盒</strong>：採用 Training v1.2 的 <code>system_total_kw</code> 作為預設預測目標，透過 Model Registry Index 統一管理<br />
2. <strong>特徵向量化</strong>：明確定義 <code>FeatureVectorizer</code> 處理配置到特徵的轉換，確保與訓練時特徵工程一致<br />
3. <strong>版本控制</strong>：支援 <code>pinned_timestamp</code> 鎖定模型版本，確保離線分析的重現性<br />
4. <strong>Hybrid 驗證</strong>：保留對 Component Models 的載入能力，用於診斷與交叉驗證，但以 System Model 為優化依據<br />
5. <strong>環境資料</strong>：支援從 CSV 批次讀取環境條件，滿足離線批次模擬需求<br />
6. <strong>錯誤碼對齊</strong>：與 Training v1.2 錯誤碼體系一致（E801-E805, E901, E903）<br />
```</p>
</body>
</html>