<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PRD_Chiller_Plant_Optimization_V1.2</title>

<style>
body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
    font-size: 16px;
    line-height: 1.5;
    word-wrap: break-word;
    color: #24292e;
    background-color: #fff;
    max-width: 900px;
    margin: 0 auto;
    padding: 2rem;
}
h1, h2, h3, h4, h5, h6 {
    margin-top: 24px;
    margin-bottom: 16px;
    font-weight: 600;
    line-height: 1.25;
}
h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
h3 { font-size: 1.25em; }
code {
    padding: 0.2em 0.4em;
    margin: 0;
    font-size: 85%;
    background-color: #f6f8fa;
    border-radius: 6px;
    font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
}
pre {
    padding: 16px;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f6f8fa;
    border-radius: 6px;
}
pre code {
    display: inline;
    padding: 0;
    margin: 0;
    overflow: visible;
    line-height: inherit;
    word-wrap: normal;
    background-color: initial;
    border: 0;
}
blockquote {
    padding: 0 1em;
    color: #6a737d;
    border-left: 0.25em solid #dfe2e5;
    margin: 0;
}
table {
    display: block;
    width: 100%;
    margin-top: 0;
    margin-bottom: 16px;
    overflow: auto;
    border-spacing: 0;
    border-collapse: collapse;
}
table th, table td {
    padding: 6px 13px;
    border: 1px solid #dfe2e5;
}
table tr {
    background-color: #fff;
    border-top: 1px solid #c6cbd1;
}
table tr:nth-child(2n) {
    background-color: #f6f8fa;
}
a { color: #0366d6; text-decoration: none; }
a:hover { text-decoration: underline; }
hr {
    height: 0.25em;
    padding: 0;
    margin: 24px 0;
    background-color: #e1e4e8;
    border: 0;
}
</style>

</head>
<body>
<h1 id="prd-v12-chiller-plant-optimization-engine">PRD v1.2: 冰水主機房最佳化引擎 (Chiller Plant Optimization Engine)</h1>
<h1 id="fallback">離線建議模式：設備組合最佳化、節能評估與強健性 Fallback 機制</h1>
<p><strong>文件版本:</strong> v1.2 (Robust Optimization &amp; Interface Contract Alignment)<br />
<strong>日期:</strong> 2026-02-14<br />
<strong>負責人:</strong> Oscar Chang<br />
<strong>目標模組:</strong> <code>src/optimization/engine.py</code>, <code>src/optimization/constraints.py</code>, <code>src/optimization/scenarios.py</code>, <code>src/optimization/model_interface.py</code>, <code>src/optimization/fallback.py</code> (新增)<br />
<strong>上游契約:</strong> <br />
- <code>src/modeling/training_pipeline.py</code> (v1.2+, Model Registry Index)<br />
- <code>src/etl/interface_contract.py</code> (v1.1+, Temporal Baseline &amp; Feature Alignment)<br />
<strong>關鍵相依:</strong> <br />
- <code>src/features/annotation_manager.py</code> (v1.2+, 提供物理限制與設備角色)<br />
- <code>src/equipment/equipment_validator.py</code> (v1.0+, Equipment Validation Sync)<br />
<strong>預估工時:</strong> 8 ~ 9 個工程天（含 Fallback 機制、暖啟動、資源管理與 Interface Contract 對齊）</p>
<hr />
<h2 id="1">1. 執行總綱與設計哲學</h2>
<h3 id="11">1.1 核心目標</h3>
<p>建立<strong>生產就緒 (Production-Ready)</strong> 的離線配置最佳化引擎，採用<strong>系統級黑盒建模（System-Level Blackbox）</strong>策略，支援兩種工程決策模式，並具備<strong>多層次降級（Multi-Level Fallback）</strong>能力：</p>
<ol>
<li><strong>負載驅動模式 (Load-Driven)</strong>：給定目標冷凍噸 RT，輸出最佳設備組合以達到最低總耗電 kW</li>
<li><strong>效率驅動模式 (Efficiency-Driven)</strong>：給定目標效率 kW/RT，反推設備參數配置，並提供改善前後節能量評估</li>
<li><strong>強健性 Fallback 機制</strong>：當數學規劃無解（Infeasible）、求解超時（Timeout）或記憶體不足時，自動降級為啟發式算法或回傳部分解，確保工程師始終獲得「可行且合理」的建議，而非系統錯誤</li>
</ol>
<h3 id="12-v12">1.2 設計原則（v1.2 強化）</h3>
<ol>
<li><strong>防禦性優化 (Defensive Optimization)</strong>：寧可產出「次佳但可行」的解，也不因數學限制而崩潰。導入 <strong>Three-Level Fallback Strategy</strong>（見第4章）</li>
<li><strong>系統級黑盒優先</strong>: 採用 Model Training v1.2 的 <code>system_total_kw</code> 作為單一預測目標，透過 Model Registry Index 載入，確保預測精度與設備耦合效應（Copula effect）的完整性</li>
<li><strong>混合整數規劃 (MIP) + 連續優化 + 啟發式備援</strong>：設備啟停為離散變數（0/1），頻率轉速為連續變數（Hz/%），當求解器失敗時自動切換至 Greedy Heuristic</li>
<li><strong>物理邏輯一致性 (Physics Logic Consistency)</strong>：與 Data Cleaner 的設備驗證邏輯同步（Interface Contract v1.1 第11章），防止「清洗時未檢測違規，優化時卻發現不可行」的邏輯脫鉤</li>
<li><strong>多案場繼承</strong>：支援 <code>base.yaml</code> → <code>site.yaml</code> 的設定繼承，不同案場可覆寫設備數量、效率曲線、約束條件</li>
<li><strong>模型版本綁定與特徵對齊</strong>：強制驗證 <code>model_registry_index.json</code> 中的 <code>annotation_checksum</code> 與當前 Feature Annotation v1.2 的相容性；嚴格執行 Feature Alignment Check（E901-E904）確保訓練與推論特徵順序一致</li>
<li><strong>時間基準隔離 (Temporal Baseline Isolation)</strong>：Optimization 階段產生新的 <code>pipeline_origin_timestamp</code>，與 Training 階段區隔，防止時間漂移導致的資料洩漏误判</li>
<li><strong>暖啟動與資源感知 (Warm Start &amp; Resource-Aware)</strong>：批次優化時支援序列暖啟動，降低 30-50% 迭代次數；動態記憶體預估防止設備組合枚舉時的 OOM</li>
</ol>
<h3 id="13">1.3 與上游模組的關係</h3>
<pre><code class="language-mermaid">graph LR
    A[Model Training v1.2&lt;br/&gt;Model Registry Index] --&gt;|載入 system_total_kw&lt;br/&gt;驗證 checksum| B[Optimization Engine v1.2]
    C[Feature Annotation v1.2&lt;br/&gt;physical_types.yaml] --&gt;|物理限制&lt;br/&gt;valid_range| B
    D[Optimization Config&lt;br/&gt;sites/{site_id}.yaml] --&gt;|邏輯約束&lt;br/&gt;設備依賴關係| B
    E[工程師輸入&lt;br/&gt;RT 或 kW/RT 目標] --&gt;|最佳化目標| B
    F[環境資料&lt;br/&gt;weather.csv] --&gt;|外氣條件| B
    G[Interface Contract v1.1&lt;br/&gt;Temporal Baseline] --&gt;|時間基準隔離&lt;br/&gt;Feature Alignment| B
    H[Equipment Validator&lt;br/&gt;Validation Sync] --&gt;|物理邏輯預檢&lt;br/&gt;E350-E352| B

    B --&gt;|配置建議| I[Fallback Handler&lt;br/&gt;三級降級機制]
    I --&gt;|最終輸出| J[離線報告&lt;br/&gt;改善前/後評估&lt;br/&gt;敏感性分析]

    style B fill:#f9f,stroke:#333,stroke-width:4px
    style I fill:#ff9,stroke:#f60,stroke-width:3px
    style J fill:#bbf,stroke:#00f,stroke-width:2px
</code></pre>
<h3 id="14">1.4 訓練模式銜接策略</h3>
<p>本引擎<strong>預設採用 System-Level 黑盒模式</strong>（對應 Training v1.2 模式 A），原因：<br />
1. 考慮設備間耦合效應（Copula effect），預測精度最高<br />
2. 簡化優化邏輯（單一預測目標）<br />
3. 與 Model Registry Index 標準格式無縫整合</p>
<p><strong>當 Training 採用 Hybrid 模式（模式 C）時</strong>：<br />
- Optimization Engine 以 <code>system_total_kw</code> 為主要預測依據（必要）<br />
- Component-Level 模型（<code>chiller_1_kw</code> 等）僅用於節能報告中的耗電佔比分析（選用）<br />
- 若 System Model 與 Component Models 加總差異 &gt;5%，觸發警告 <strong>E806</strong>，但仍以 System Model 為準<br />
- <strong>新增</strong>：若差異 &gt;15%，觸發 <strong>E810</strong>（模型嚴重不一致錯誤），強制終止並要求重新訓練</p>
<hr />
<h2 id="2-interface-contracts">2. 介面契約規範 (Interface Contracts)</h2>
<h3 id="21-input-contract-from-model-training-v12-interface-contract-v11">2.1 輸入契約 (Input Contract from Model Training v1.2 &amp; Interface Contract v1.1)</h3>
<p><strong>檢查點 #8: Model Training → Optimization Engine</strong></p>
<p>Optimization Engine 不再直接載入個別 <code>.joblib</code> 檔案，而是透過 <strong>Model Registry Index</strong> 統一管理，並強制執行特徵對齊驗證：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">檢查項</th>
<th style="text-align: left;">規格</th>
<th style="text-align: center;">錯誤代碼</th>
<th style="text-align: left;">處理</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Registry Index 存在</strong></td>
<td style="text-align: left;"><code>models/{site_id}/model_registry_index.json</code> 必須存在</td>
<td style="text-align: center;">E801</td>
<td style="text-align: left;">拒絕載入</td>
</tr>
<tr>
<td style="text-align: left;"><strong>目標模型可用</strong></td>
<td style="text-align: left;"><code>system_total_kw</code> 必須在 <code>available_models</code> 中且 <code>optional: false</code></td>
<td style="text-align: center;">E804</td>
<td style="text-align: left;">拒絕載入</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Annotation 版本相容</strong></td>
<td style="text-align: left;"><code>annotation_checksum</code> 比對當前 FeatureAnnotationManager</td>
<td style="text-align: center;">E802</td>
<td style="text-align: left;">拒絕載入</td>
</tr>
<tr>
<td style="text-align: left;"><strong>特徵維度對齊</strong></td>
<td style="text-align: left;"><code>feature_count</code> 與 Optimization Config 特徵數一致</td>
<td style="text-align: center;">E803</td>
<td style="text-align: left;">拒絕載入</td>
</tr>
<tr>
<td style="text-align: left;"><strong>特徵順序嚴格比對</strong></td>
<td style="text-align: left;">輸入特徵順序必須與 Training <code>feature_order_manifest</code> 完全一致</td>
<td style="text-align: center;"><strong>E901</strong></td>
<td style="text-align: left;">拒絕載入（Interface Contract v1.1）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>縮放參數驗證</strong></td>
<td style="text-align: left;"><code>scaler_params</code> 必須存在且特徵順序與模型一致</td>
<td style="text-align: center;"><strong>E903</strong></td>
<td style="text-align: left;">拒絕載入</td>
</tr>
<tr>
<td style="text-align: left;"><strong>設備限制一致性</strong></td>
<td style="text-align: left;">當前 Optimization Config 的設備限制必須與 Training 時記錄的 <code>equipment_constraints_applied</code> 相容</td>
<td style="text-align: center;"><strong>E904</strong></td>
<td style="text-align: left;">警告（可覆寫）或拒絕（嚴格模式）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>模型檔案完整性</strong></td>
<td style="text-align: left;">Manifest 中引用的 <code>.joblib</code> 檔案存在且 checksum 驗證通過</td>
<td style="text-align: center;">E801</td>
<td style="text-align: left;">拒絕載入</td>
</tr>
<tr>
<td style="text-align: left;"><strong>時間基準隔離</strong></td>
<td style="text-align: left;">Optimization 必須產生新的 <code>pipeline_origin_timestamp</code>，不可沿用 Training 的時間戳</td>
<td style="text-align: center;"><strong>E000-W</strong></td>
<td style="text-align: left;">警告（若沿用）</td>
</tr>
</tbody>
</table>
<p><strong>ModelRegistry 實作規範（v1.2 更新）</strong>：</p>
<pre><code class="language-python">class ModelRegistry:
    &quot;&quot;&quot;
    模型註冊表：載入與驗證 Model Training v1.2 輸出
    統一透過 model_registry_index.json 作為入口
    嚴格執行 Interface Contract v1.1 的特徵對齊與設備限制一致性檢查
    &quot;&quot;&quot;

    def load_from_registry(
        self, 
        site_id: str, 
        target_id: str = &quot;system_total_kw&quot;,
        pinned_timestamp: Optional[str] = None,
        strict_feature_alignment: bool = True,  # v1.2 新增：嚴格特徵對齊模式
        temporal_baseline: Optional[datetime] = None  # v1.2 新增：時間基準傳遞
    ) -&gt; MultiModelArtifact:
        &quot;&quot;&quot;
        載入流程：
        1. 讀取 models/{site_id}/model_registry_index.json
        2. 驗證 schema_version &gt;= 1.2
        3. 驗證 annotation_checksum（E802）
        4. 依 target_id 找到對應 ModelEntry
        5. 若 pinned_timestamp 指定，載入該版本；否則載入最新版本
        6. 載入該 target 的 ensemble_manifest.json
        7. 驗證 model 檔案 checksum
        8. 載入 feature_manifest.json（Interface Contract v1.1 檢查點 #7）
        9. 驗證設備限制一致性（E904）
        10. 回傳 MultiModelArtifact（含最佳模型與備援模型）

        Args:
            site_id: 案場識別碼
            target_id: 預設 &quot;system_total_kw&quot;，可選 &quot;chiller_1_kw&quot; 等（Hybrid 診斷用）
            pinned_timestamp: 鎖定特定版本（格式：YYYYMMDD_HHMMSS），確保重現性
            strict_feature_alignment: 是否嚴格比對特徵順序（建議 True）
            temporal_baseline: Pipeline 時間基準（用於驗證模型新鮮度）

        Raises:
            E801: Model Registry Index 不存在或模型檔案遺失
            E802: Annotation checksum 不匹配
            E804: 請求的 target_id 不可用
            E901: 特徵順序/名稱與訓練時不一致（Feature Alignment Error）
            E903: 縮放參數缺失或順序錯誤
            E904: 設備限制與訓練時不一致（Equipment Constraint Inconsistency）
        &quot;&quot;&quot;

    def validate_feature_alignment(
        self,
        model_artifact: Dict,
        current_feature_names: List[str],
        current_scaler_params: Optional[Dict] = None
    ) -&gt; Tuple[bool, List[str]]:
        &quot;&quot;&quot;
        嚴格特徵對齊驗證（Interface Contract v1.1 第9章實作）

        驗證項目：
        1. 特徵數量一致性（E902）
        2. 特徵名稱與順序逐個比對（E901）
        3. 特徵雜湊驗證（可選但建議）
        4. 縮放參數對齊（E903）

        Returns:
            (is_aligned, mismatch_details)
        &quot;&quot;&quot;

    def validate_hybrid_consistency(
        self, 
        site_id: str,
        config: Dict, 
        ambient: Dict,
        tolerance: float = 0.05,
        strict_tolerance: float = 0.15  # v1.2 新增：嚴重偏差閾值
    ) -&gt; Tuple[bool, float, str]:
        &quot;&quot;&quot;
        Hybrid 模式一致性檢查（強化版）：
        - 使用 system_total_kw 預測總耗電
        - 使用各 component models 預測並加總
        - 比較兩者差異百分比

        Returns:
            (is_consistent, discrepancy_percent, severity)
            severity: &quot;normal&quot; (&lt;=5%), &quot;warning&quot; (5-15%), &quot;critical&quot; (&gt;15%, 觸發 E810)
        &quot;&quot;&quot;
</code></pre>
<h3 id="22-feature-vectorization-with-alignment">2.2 特徵向量化契約 (Feature Vectorization with Alignment)</h3>
<p><strong>檢查點 #8.5: Optimization Config → Model Features</strong></p>
<p>將設備配置（離散+連續變數）轉換為模型輸入特徵向量，需與 Training v1.2 的特徵工程邏輯完全一致，並執行嚴格對齊：</p>
<pre><code class="language-python">class FeatureVectorizer:
    &quot;&quot;&quot;
    將 Optimization 的設備配置轉換為 ML 模型輸入特徵
    確保特徵順序、名稱、縮放方式與訓練時一致
    嚴格執行 Interface Contract v1.1 的特徵對齊規範
    &quot;&quot;&quot;

    def __init__(
        self, 
        site_config: OptimizationConfig, 
        model_features: List[str],
        scaler_params: Optional[Dict] = None,  # v1.2 新增：從 Model Registry 載入
        equipment_constraints: Optional[List[str]] = None  # v1.2 新增：設備限制上下文
    ):
        &quot;&quot;&quot;
        Args:
            site_config: 案場設備配置（含設備 ID 對應關係）
            model_features: 從 ModelEntry 讀取的特徵名稱列表（順序敏感）
            scaler_params: 訓練時的 StandardScaler 參數（mean_, scale_）
            equipment_constraints: 訓練時套用的設備限制清單（供 E904 驗證）
        &quot;&quot;&quot;
        self.model_features = model_features
        self.feature_scalers = scaler_params  # v1.2：從 Training 繼承的縮放參數
        self.equipment_constraints = equipment_constraints or []
        self.constraint_checker = ConstraintValidator(site_config)

    def vectorize(
        self, 
        discrete_vars: Dict[str, bool],      # 如 {&quot;chiller_1_on&quot;: True, &quot;chiller_2_on&quot;: False}
        continuous_vars: Dict[str, float],   # 如 {&quot;chiller_1_load_percent&quot;: 0.6, &quot;chw_pump_1_hz&quot;: 45}
        ambient: Dict[str, float]            # 如 {&quot;wet_bulb_temp&quot;: 26.5, &quot;dry_bulb_temp&quot;: 32.0}
    ) -&gt; np.ndarray:
        &quot;&quot;&quot;
        轉換邏輯：
        1. 合併 discrete_vars（bool → float 1.0/0.0）
        2. 合併 continuous_vars（單位轉換：Hz→%，RT→正規化等）
        3. 合併 ambient（外氣條件）
        4. 依照 self.model_features 的順序排列（嚴格對齊）
        5. 套用特徵縮放（使用訓練時的 StandardScaler 參數）
        6. 記錄轉換日誌（供除錯）

        Returns:
            np.ndarray: shape (n_features,)

        Raises:
            E901: 若輸入變數無法產生所有 model_features 所需欄位
        &quot;&quot;&quot;

    def validate_alignment(self, strict: bool = True) -&gt; Tuple[bool, List[str]]:
        &quot;&quot;&quot;
        驗證 E803/E901：確保 Optimization Config 能產生所有 model_features 所需的欄位
        回傳 False 表示缺少必要特徵，無法進行預測

        Args:
            strict: 是否嚴格比對（True 時檢查順序，False 僅檢查存在性）
        &quot;&quot;&quot;

    def validate_equipment_consistency(self, current_constraints: List[str]) -&gt; bool:
        &quot;&quot;&quot;
        驗證 E904：檢查當前設備限制與訓練時是否一致
        &quot;&quot;&quot;
        return set(self.equipment_constraints) == set(current_constraints)
</code></pre>
<h3 id="23">2.3 約束條件來源（雙軌制 + 物理邏輯同步）</h3>
<table>
<thead>
<tr>
<th style="text-align: left;">約束類型</th>
<th style="text-align: left;">來源</th>
<th style="text-align: left;">內容範例</th>
<th style="text-align: center;">嚴格度</th>
<th style="text-align: left;">同步機制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>物理限制</strong></td>
<td style="text-align: left;">Feature Annotation v1.2</td>
<td style="text-align: left;"><code>chiller_out_temp &gt;= 6.5</code> (°C), <code>pump_hz &lt;= 60</code></td>
<td style="text-align: center;">硬約束 (Hard)</td>
<td style="text-align: left;">與 Cleaner 共用 <code>valid_range</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>邏輯約束</strong></td>
<td style="text-align: left;">Optimization Config v1.2</td>
<td style="text-align: left;"><code>chiller_1_on → ct_1_on</code> (開主機1必須開冷卻塔1)</td>
<td style="text-align: center;">硬約束 (Hard)</td>
<td style="text-align: left;">與 Equipment Validator 同步（E350-E352）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>運行邊界</strong></td>
<td style="text-align: left;">Optimization Config v1.2</td>
<td style="text-align: left;"><code>min_chiller_load = 30%</code> (最低載率限制)</td>
<td style="text-align: center;">硬約束 (Hard)</td>
<td style="text-align: left;">動態載入 from site.yaml</td>
</tr>
<tr>
<td style="text-align: left;"><strong>偏好約束</strong></td>
<td style="text-align: left;">Optimization Config v1.2</td>
<td style="text-align: left;"><code>prefer_backup = true</code> (優先使用備用機組)</td>
<td style="text-align: center;">軟約束 (Soft)</td>
<td style="text-align: left;">目標函數權重調整</td>
</tr>
<tr>
<td style="text-align: left;"><strong>時間約束</strong></td>
<td style="text-align: left;">Optimization Config v1.2</td>
<td style="text-align: left;"><code>min_runtime = 30min</code>, <code>min_downtime = 15min</code></td>
<td style="text-align: center;">硬約束 (Hard)</td>
<td style="text-align: left;">與 Cleaner 的 Sequence Validation 同步</td>
</tr>
</tbody>
</table>
<h3 id="24-v12">2.4 工程師輸入介面（v1.2 強化）</h3>
<pre><code class="language-python">class OptimizationRequest(BaseModel):
    &quot;&quot;&quot;最佳化請求（離線模式）&quot;&quot;&quot;

    # 案場識別
    site_id: str

    # 模式選擇（互斥）
    mode: Literal[&quot;load_driven&quot;, &quot;efficiency_driven&quot;]

    # 模式 A：負載驅動
    target_rt: Optional[float] = None  # 目標冷凍噸，例如 500.0 RT

    # 模式 B：效率驅動
    target_kw_per_rt: Optional[float] = None  # 目標效率，例如 0.65 kW/RT

    # 環境條件（對應審查報告 3.1 建議）
    ambient_conditions: Optional[Dict[str, float]] = None  # 即時指定
    ambient_file: Optional[str] = None  # 從 CSV 檔案讀取歷史天氣資料進行批次模擬

    # 運行邊界（可選，覆寫 Config 預設）
    constraints_override: Optional[Dict] = None

    # 當前狀態（用於改善前後比較）
    current_config: Optional[Dict] = None  # 例如 {&quot;chiller_count&quot;: 2, &quot;pump_hz&quot;: 45, ...}

    # 模型版本控制（v1.1 延續）
    model_version_policy: Optional[Dict] = {
        &quot;auto_update&quot;: False,                    # 是否自動使用最新訓練的模型
        &quot;pinned_timestamp&quot;: None,                # 鎖定特定版本（確保重現性）
        &quot;fallback_on_error&quot;: True                # 載入失敗時是否允許使用次佳模型
    }

    # v1.2 新增：Fallback 控制
    fallback_policy: FallbackPolicy = FallbackPolicy(
        enabled=True,                           # 是否啟用降級機制
        max_fallback_level=3,                   # 最大降級層級（1-3）
        timeout_seconds=300,                    # 求解超時時間（預設5分鐘）
        allow_partial_solution=True,            # 超時時是否回傳部分解
        enable_warm_start=True                  # 是否啟用暖啟動（批次模式）
    )

    # v1.2 新增：報告深度控制
    report_depth: Literal[&quot;basic&quot;, &quot;standard&quot;, &quot;advanced&quot;] = &quot;standard&quot;
    # basic: 僅建議配置與預測能耗
    # standard: 增加節能評估與 Hybrid 檢查
    # advanced: 增加敏感性分析、Pareto Frontier、What-if 比較

class FallbackPolicy(BaseModel):
    &quot;&quot;&quot;Fallback 策略配置（v1.2 新增）&quot;&quot;&quot;
    enabled: bool = True
    max_fallback_level: int = Field(3, ge=1, le=3)  # 1:放寬軟約束, 2:啟發式, 3:回傳當前配置
    timeout_seconds: int = Field(300, ge=60)        # 最短 60 秒
    allow_partial_solution: bool = True             # 是否允許部分解
    enable_warm_start: bool = True                  # 批次優化時啟用暖啟動

class OptimizationResponse(BaseModel):
    &quot;&quot;&quot;最佳化回應（v1.2 強化版）&quot;&quot;&quot;

    # 最佳化結果
    recommended_config: Dict  # 設備組合與參數
    predicted_kw: float       # 預測總耗電（來自 system_total_kw 模型）
    predicted_kw_per_rt: float  # 預測效率

    # 預測信心區間（若使用 Random Forest 或啟用區間預測）
    prediction_interval: Optional[Dict[str, float]] = None  # {&quot;lower&quot;: 290, &quot;upper&quot;: 310}

    # 改善評估（若提供 current_config）
    baseline_kw: Optional[float] = None
    savings_kw: Optional[float] = None
    savings_percent: Optional[float] = None
    annual_savings_estimate: Optional[float] = None  # 年度預估節電量 (kWh)

    # Hybrid 模式診斷資訊（若 Component Models 可用）
    component_breakdown: Optional[Dict[str, float]] = None  # {&quot;chiller_1_kw&quot;: 150, &quot;pump_kw&quot;: 30, ...}
    hybrid_consistency_check: Optional[Dict] = None  # {&quot;system_pred&quot;: 300, &quot;component_sum&quot;: 295, &quot;discrepancy&quot;: 1.7%}

    # v1.2 新增：Fallback 狀態追蹤
    fallback_status: Optional[FallbackStatus] = None  # 降級狀態追蹤
    solver_metadata: Optional[SolverMetadata] = None   # 求解器執行資訊

    # 約束狀態
    constraint_violations: List[str]  # 若有軟約束違反
    binding_constraints: List[str]    # 起作用的有效約束

    # 模型資訊
    model_used: str                   # 實際使用的模型名稱（如 &quot;xgboost&quot;）
    model_timestamp: str              # 模型版本時間戳

    # v1.2 新增：進階報告內容（依 report_depth）
    sensitivity_analysis: Optional[SensitivityReport] = None  # 敏感性分析
    pareto_frontier: Optional[List[Dict]] = None              # 多目標 Pareto 前沿
    what_if_comparison: Optional[WhatIfReport] = None         # 情境比較

    # 報告
    recommendation_text: str  # 工程師可讀的建議說明
    scenario_analysis: Optional[Dict] = None  # 多情境比較（如開1台vs2台）

class FallbackStatus(BaseModel):
    &quot;&quot;&quot;降級狀態（v1.2 新增）&quot;&quot;&quot;
    fallback_triggered: bool = False      # 是否觸發降級
    fallback_level: int = 0               # 實際使用的降級層級（0=未降級）
    original_error: Optional[str] = None  # 原始錯誤代碼（如 E806, E809）
    fallback_strategy: Optional[str] = None  # 使用的降級策略說明
    solution_quality: Literal[&quot;optimal&quot;, &quot;feasible&quot;, &quot;heuristic&quot;, &quot;current&quot;] = &quot;optimal&quot;

class SolverMetadata(BaseModel):
    &quot;&quot;&quot;求解器元資料（v1.2 新增）&quot;&quot;&quot;
    algorithm: str                        # 使用的算法（如 &quot;differential_evolution&quot;）
    iterations: int                       # 實際迭代次數
    timeout_triggered: bool = False       # 是否因超時終止
    convergence_status: str               # 收斂狀態（converged/max_iter/timeout/infeasible）
    objective_evaluations: int            # 目標函數評估次數
    warm_start_used: bool = False         # 是否使用暖啟動
</code></pre>
<hr />
<h2 id="3">3. 系統架構與核心模組</h2>
<h3 id="31-feature-annotation-v12">3.1 多案場配置系統（繼承 Feature Annotation v1.2 模式）</h3>
<p><strong>檔案結構</strong>：</p>
<pre><code>config/optimization/
├── base.yaml                    # 基礎設備模型與通用約束
├── sites/
│   ├── cgmh_ty.yaml            # 長庚醫院桃園院區（繼承 base）
│   └── farglory_o3.yaml        # 遠雄 O3（繼承 base）
└── schemas/
    └── optimization_schema.json # JSON Schema 驗證（v1.2 更新：增加 fallback_policy）
</code></pre>
<p><strong>base.yaml 範例（v1.2 更新版）</strong>：</p>
<pre><code class="language-yaml">schema_version: &quot;1.2&quot;
inherit: &quot;none&quot;

# 模型註冊表設定（v1.1 延續）
model_registry:
  index_file: &quot;models/{site_id}/model_registry_index.json&quot;
  default_target: &quot;system_total_kw&quot;
  fallback_to_components: false
  version_policy:
    auto_update: false
    pinned_timestamp: null
  # v1.2 新增：特徵對齊設定
  feature_alignment:
    strict_order: true              # 嚴格特徵順序比對
    validate_hash: true             # 驗證特徵雜湊
    enforce_equipment_constraints: true  # 強制設備限制一致性（E904）

# 設備清單與規格（移除 model_file，改為純配置）
equipment:
  chillers:
    - id: chiller_1
      type: centrifugal
      capacity_rt: 300
      min_load_percent: 30
      dependencies: [&quot;chw_pump_1&quot;, &quot;ct_1&quot;]
      device_role: primary

    - id: chiller_2
      type: screw
      capacity_rt: 200
      min_load_percent: 25
      dependencies: [&quot;chw_pump_2&quot;, &quot;ct_2&quot;]
      device_role: backup

  pumps:
    - id: chw_pump_1
      type: chilled_water
      max_hz: 60
      min_hz: 30
      efficiency_curve: &quot;pump_curve_1.json&quot;

  cooling_towers:
    - id: ct_1
      type: induced_draft
      capacity_kw: 1500
      fan_speed_min: 30
      fan_speed_max: 100

# 特徵映射設定（v1.1 延續）
feature_mapping:
  mappings:
    chiller_1_on: &quot;chiller_1_status&quot;
    chiller_1_load_percent: &quot;chiller_1_load_ratio&quot;
    chw_pump_1_hz: &quot;chw_pump_1_frequency&quot;
    wet_bulb_temp: &quot;ambient_wb_temp&quot;

# 邏輯約束定義（Logic Constraints）
logic_constraints:
  # 互鎖約束（Interlock）
  - type: requires
    if: &quot;chiller_1_on&quot;
    then: [&quot;chw_pump_1_on&quot;, &quot;ct_1_on&quot;]
    critical: true                 # v1.2 新增：標記為關鍵約束（不可放寬）

  - type: requires
    if: &quot;chiller_2_on&quot;
    then: [&quot;chw_pump_2_on&quot;, &quot;ct_2_on&quot;]
    critical: true

  # 互斥約束（Mutual Exclusion）
  - type: mutex
    devices: [&quot;chiller_1&quot;, &quot;chiller_2&quot;]
    reason: &quot;電力容量限制，不可同時滿載&quot;
    soft: true                     # v1.2 新增：標記為軟約束（可放寬）

  # 順序約束（Sequence）
  - type: sequence
    startup: [&quot;ct_1&quot;, &quot;chw_pump_1&quot;, &quot;chiller_1&quot;]
    shutdown: [&quot;chiller_1&quot;, &quot;chw_pump_1&quot;, &quot;ct_1&quot;]

  # 運行時間約束（v1.1 延續）
  - type: min_runtime
    device: &quot;chiller_1&quot;
    minutes: 30

  - type: min_downtime
    device: &quot;chiller_1&quot;
    minutes: 15

# v1.2 新增：Fallback 策略設定
fallback:
  enabled: true
  default_timeout: 300             # 秒
  max_level: 3
  level_settings:
    level_1:                       # 放寬軟約束
      relax_soft_constraints: true
      relax_tolerance: 0.1         # 放寬 10%
    level_2:                       # 啟發式算法
      use_greedy_heuristic: true
      max_iterations: 1000
    level_3:                       # 回傳當前配置
      return_current_config: true
      generate_diagnostic_report: true  # 產生診斷報告說明為何無法優化

# 優化參數
optimization:
  algorithm: &quot;differential_evolution&quot;  # 主要算法
  backup_algorithm: &quot;slsqp&quot;            # v1.2 新增：備援算法（連續變數優化）
  max_iter: 1000
  population_size: 50
  constraint_tolerance: 0.01

  # 切換懲罰（v1.1 延續）
  switching_penalty_kw: 5.0

  # 目標函數權重（多目標時使用）
  objectives:
    - name: &quot;total_kw&quot;
      weight: 0.7
    - name: &quot;equipment_wear&quot;
      weight: 0.3

  # v1.2 新增：資源限制
  resource_limits:
    max_memory_gb: 4.0               # 單一優化任務記憶體上限
    max_concurrent_evaluations: 8    # 平行評估目標函數上限
    enable_memory_monitor: true      # 啟用記憶體監控

# 物理限制（可覆寫 Annotation 的值，但建議保持一致）
physical_constraints:
  chiller_out_temp:
    min: 6.5
    max: 8.0
</code></pre>
<h3 id="32-constraint-engine-with-physics-sync">3.2 約束引擎（Constraint Engine with Physics Sync）</h3>
<p><strong>檔案</strong>: <code>src/optimization/constraints.py</code></p>
<p><strong>核心類別（v1.2 更新）</strong>：</p>
<pre><code class="language-python">class ConstraintEngine:
    &quot;&quot;&quot;
    統一約束管理器（v1.2 強化版）
    整合物理限制（來自 Annotation）、邏輯約束（來自 Config）
    並與 Equipment Validator 同步（Interface Contract v1.1 第11章）
    &quot;&quot;&quot;

    def __init__(
        self, 
        site_config: OptimizationConfig, 
        annotation_manager: FeatureAnnotationManager,
        equipment_validator: Optional[EquipmentValidator] = None  # v1.2 新增
    ):
        self.physical_limits = self._load_physical_limits(annotation_manager)
        self.logic_constraints = LogicConstraintGraph(site_config.logic_constraints)
        self.equipment_specs = site_config.equipment
        self.switching_penalty = site_config.optimization.switching_penalty_kw
        self.equipment_validator = equipment_validator  # v1.2：用於物理邏輯預檢

        # v1.2 新增：約束分類（區分可放寬與不可放寬）
        self.hard_constraints = []
        self.soft_constraints = []
        self._classify_constraints(site_config.logic_constraints)

    def _classify_constraints(self, constraints: List[Dict]):
        &quot;&quot;&quot;將約束分類為硬約束與軟約束（v1.2 新增）&quot;&quot;&quot;
        for c in constraints:
            if c.get('critical', False) or c['type'] in ['requires', 'sequence']:
                self.hard_constraints.append(c)
            elif c.get('soft', False):
                self.soft_constraints.append(c)
            else:
                # 預設：互鎖為硬，互斥為軟
                if c['type'] == 'mutex':
                    self.soft_constraints.append(c)
                else:
                    self.hard_constraints.append(c)

    def validate_configuration(
        self, 
        config: Dict, 
        check_physics: bool = True,  # v1.2 新增：是否執行物理邏輯預檢
        runtime_history: Optional[Dict] = None
    ) -&gt; Tuple[bool, List[str], List[str]]:
        &quot;&quot;&quot;
        驗證給定配置是否滿足所有硬約束（v1.2 強化版）

        Returns:
            (is_feasible, hard_violations, soft_violations)
            is_feasible: 是否滿足所有硬約束
            hard_violations: 硬約束違反列表（不可放寬）
            soft_violations: 軟約束違反列表（可放寬）
        &quot;&quot;&quot;
        hard_violations = []
        soft_violations = []

        # 1. 硬約束檢查（不可放寬）
        if not self.logic_constraints.check(config, constraint_type='hard'):
            hard_violations.extend(self.logic_constraints.get_violations('hard'))

        # 2. 物理限制檢查
        for device_id, params in config.items():
            limits = self.physical_limits.get(device_id, {})
            if not self._check_limits(params, limits):
                hard_violations.append(f&quot;Physical limit violated: {device_id}&quot;)

        # 3. 設備規格檢查
        for eq_type, devices in self.equipment_specs.items():
            for device in devices:
                if not self._check_equipment_spec(config, device):
                    hard_violations.append(f&quot;Equipment spec violated: {device.id}&quot;)

        # 4. 運行時間約束檢查
        if not self._check_runtime_constraints(config, runtime_history):
            hard_violations.append(&quot;Runtime constraint violated: min_runtime/min_downtime&quot;)

        # 5. v1.2 新增：物理邏輯預檢（與 Cleaner 同步）
        if check_physics and self.equipment_validator:
            physics_errors = self.equipment_validator.validate_operation_state(config)
            if physics_errors:
                hard_violations.extend([f&quot;Physics sync: {e}&quot; for e in physics_errors])

        # 6. 軟約束檢查（可放寬）
        if not self.logic_constraints.check(config, constraint_type='soft'):
            soft_violations.extend(self.logic_constraints.get_violations('soft'))

        is_feasible = len(hard_violations) == 0
        return is_feasible, hard_violations, soft_violations

    def relax_soft_constraints(self, tolerance: float = 0.1) -&gt; 'ConstraintEngine':
        &quot;&quot;&quot;
        v1.2 新增：產生放寬軟約束的約束引擎副本（Fallback Level 1）

        Args:
            tolerance: 放寬容忍度（0.1 = 10%）
        &quot;&quot;&quot;
        relaxed = copy.deepcopy(self)
        for constraint in relaxed.soft_constraints:
            if 'threshold' in constraint:
                constraint['threshold'] *= (1 + tolerance)
        return relaxed

    def get_feasible_regions(self, target_rt: float) -&gt; List[Dict]:
        &quot;&quot;&quot;
        預篩選：給定目標 RT，找出所有可行的設備組合（離散變數枚舉）
        v1.2 更新：增加記憶體安全檢查，防止組合爆炸
        &quot;&quot;&quot;
        # 記憶體預檢（若設備數 &gt; 10，改用啟發式枚舉）
        total_devices = sum(len(devices) for devices in self.equipment_specs.values())
        if total_devices &gt; 10:
            logger.warning(&quot;設備數過多，啟用啟發式枚舉防止 OOM&quot;)
            return self._heuristic_enumeration(target_rt)

        # 標準枚舉邏輯（略）
        pass

    def _heuristic_enumeration(self, target_rt: float) -&gt; List[Dict]:
        &quot;&quot;&quot;v1.2 新增：啟發式枚舉（貪婪選擇優先）&quot;&quot;&quot;
        pass
</code></pre>
<h3 id="33-fallback-v12">3.3 Fallback 處理器（v1.2 新增核心元件）</h3>
<p><strong>檔案</strong>: <code>src/optimization/fallback.py</code></p>
<p><strong>核心類別</strong>：</p>
<pre><code class="language-python">class FallbackHandler:
    &quot;&quot;&quot;
    三級降級處理器（v1.2 新增）
    處理求解失敗、超時、資源不足等異常情況
    &quot;&quot;&quot;

    def __init__(self, config: FallbackConfig):
        self.config = config
        self.level = 0
        self.trigger_reason = None

    def execute_with_fallback(
        self, 
        optimize_func: Callable,
        request: OptimizationRequest,
        *args, 
        **kwargs
    ) -&gt; Tuple[OptimizationResult, FallbackStatus]:
        &quot;&quot;&quot;
        執行優化並在失敗時自動降級

        策略：
        Level 0: 標準優化（differential_evolution + 完整約束）
        Level 1: 放寬軟約束（移除偏好約束、放寬互斥限制）
        Level 2: 啟發式算法（Greedy + 局部搜索）
        Level 3: 回傳當前配置（附帶診斷報告）
        &quot;&quot;&quot;
        start_time = time.time()
        last_exception = None

        for level in range(0, self.config.max_level + 1):
            try:
                result = self._try_optimize_at_level(
                    level, optimize_func, request, *args, **kwargs
                )

                # 檢查是否超時
                elapsed = time.time() - start_time
                if elapsed &gt; self.config.timeout_seconds:
                    if self.config.allow_partial_solution and result:
                        return result, self._create_fallback_status(
                            level, &quot;timeout_with_partial&quot;, last_exception
                        )
                    else:
                        raise OptimizationTimeoutError(f&quot;超時且無部分解: {elapsed}s&quot;)

                # 成功
                if level &gt; 0:
                    return result, self._create_fallback_status(
                        level, &quot;success_after_fallback&quot;, last_exception
                    )
                else:
                    return result, FallbackStatus(fallback_triggered=False)

            except (InfeasibleSolutionError, OptimizationDivergenceError) as e:
                last_exception = e
                logger.warning(f&quot;Level {level} 失敗: {e}，嘗試降級至 Level {level+1}&quot;)
                continue
            except OptimizationTimeoutError:
                if level &lt; self.config.max_level:
                    logger.warning(f&quot;Level {level} 超時，嘗試降級至 Level {level+1}&quot;)
                    continue
                else:
                    raise

        # 所有層級皆失敗
        return self._ultimate_fallback(request)

    def _try_optimize_at_level(
        self, 
        level: int, 
        optimize_func: Callable,
        request: OptimizationRequest,
        *args, 
        **kwargs
    ) -&gt; OptimizationResult:
        &quot;&quot;&quot;在特定降級層級執行優化&quot;&quot;&quot;

        if level == 0:
            # 標準模式
            return optimize_func(request, *args, **kwargs)

        elif level == 1:
            # Level 1: 放寬軟約束
            relaxed_request = copy.deepcopy(request)
            relaxed_request.constraints_override = {
                &quot;relax_soft_constraints&quot;: True,
                &quot;relax_tolerance&quot;: 0.1
            }
            return optimize_func(relaxed_request, *args, **kwargs)

        elif level == 2:
            # Level 2: 啟發式算法
            heuristic_optimizer = GreedyHeuristicOptimizer()
            return heuristic_optimizer.optimize(request)

        elif level == 3:
            # Level 3: 回傳當前配置
            return self._generate_current_config_solution(request)

    def _generate_current_config_solution(
        self, 
        request: OptimizationRequest
    ) -&gt; OptimizationResult:
        &quot;&quot;&quot;
        最終降級：回傳當前配置並標記為不可優化
        &quot;&quot;&quot;
        if request.current_config:
            return OptimizationResult(
                recommended_config=request.current_config,
                predicted_kw=self._predict_kw(request.current_config),
                fallback_status=FallbackStatus(
                    fallback_triggered=True,
                    fallback_level=3,
                    solution_quality=&quot;current&quot;,
                    original_error=&quot;All optimization levels failed&quot;
                ),
                recommendation_text=&quot;⚠️ 無法找到最佳化配置，建議維持當前運行參數。請檢查設備狀態或聯繫系統管理員。&quot;
            )
        else:
            raise OptimizationError(&quot;E809: 無法優化且無當前配置可回退&quot;)

class GreedyHeuristicOptimizer:
    &quot;&quot;&quot;
    貪婪啟發式優化器（v1.2 新增，用於 Fallback Level 2）
    &quot;&quot;&quot;

    def optimize(self, request: OptimizationRequest) -&gt; OptimizationResult:
        &quot;&quot;&quot;
        啟發式策略：
        1. 根據效率曲線排序設備（優先啟用高效率設備）
        2. 貪婪選擇最小滿足 RT 的設備組合
        3. 對每個組合進行局部連續變數優化（SLSQP）
        &quot;&quot;&quot;
        # 實作細節（略）
        pass

class InfeasibilityAnalyzer:
    &quot;&quot;&quot;
    不可行性診斷器（v1.2 新增）
    分析為何優化問題無解，並提供工程師可讀的診斷報告
    &quot;&quot;&quot;

    def analyze(self, violations: List[str], target_rt: float, constraints: Dict) -&gt; str:
        &quot;&quot;&quot;
        產生診斷報告，例如：
        &quot;目標冷凍噸 500 RT 超過總裝置容量 450 RT（2台主機各 300+150 RT）。
         建議：啟用備用主機 Chiller_3 或降低負載需求至 450 RT 以下。&quot;
        &quot;&quot;&quot;
        pass
</code></pre>
<hr />
<h2 id="4-phase-based-implementation">4. 分階段實作計畫 (Phase-Based Implementation)</h2>
<h3 id="phase-0-day-1">Phase 0: 模型載入與相容性驗證 (Day 1)</h3>
<p><strong>Step 0.1: ModelRegistry 實作（v1.2 重大更新：整合 Interface Contract）</strong></p>
<pre><code class="language-python">class ModelRegistry:
    &quot;&quot;&quot;
    模型註冊表：載入與驗證 Model Training v1.2 輸出
    統一透過 model_registry_index.json 作為單一入口
    嚴格執行 Interface Contract v1.1 的特徵對齊與設備限制一致性檢查
    &quot;&quot;&quot;

    def __init__(self, models_dir: str = &quot;models&quot;):
        self.models_dir = Path(models_dir)
        self.logger = logging.getLogger(__name__)
        self._cache = {}

    def load_from_registry(
        self, 
        site_id: str, 
        target_id: str = &quot;system_total_kw&quot;,
        pinned_timestamp: Optional[str] = None,
        strict_alignment: bool = True
    ) -&gt; MultiModelArtifact:
        &quot;&quot;&quot;
        載入流程（v1.2 強化）：
        1-7. （與 v1.1 相同，略）
        8. 載入 feature_manifest.json（Interface Contract v1.1）
        9. 驗證特徵順序（E901）、縮放參數（E903）
        10. 驗證設備限制一致性（E904）
        11. 回傳 MultiModelArtifact
        &quot;&quot;&quot;
        # 詳細實作（略，見第2章介面契約）

    def _validate_feature_alignment(
        self, 
        manifest: Dict, 
        site_config: OptimizationConfig
    ) -&gt; None:
        &quot;&quot;&quot;
        嚴格特徵對齊驗證（Interface Contract v1.1 第9章）
        &quot;&quot;&quot;
        expected_features = manifest['feature_specification']['feature_names']
        # 與當前 config 能產生的特徵比對
        # 若不符，拋出 E901
</code></pre>
<p><strong>Step 0.2: FeatureVectorizer 實作（v1.2 更新：整合 Equipment Validation）</strong></p>
<pre><code class="language-python">class FeatureVectorizer:
    &quot;&quot;&quot;
    將 Optimization 配置轉換為模型特徵向量（v1.2 強化版）
    &quot;&quot;&quot;

    def __init__(
        self, 
        site_config: OptimizationConfig, 
        model_features: List[str],
        scaler_params: Optional[Dict] = None,
        equipment_constraints: Optional[List[str]] = None
    ):
        # 初始化（見第2章）
        pass

    def vectorize(self, discrete_vars, continuous_vars, ambient) -&gt; np.ndarray:
        &quot;&quot;&quot;
        轉換邏輯（見第2章）
        &quot;&quot;&quot;
        pass

    def validate_equipment_consistency(self, current_constraints: List[str]) -&gt; bool:
        &quot;&quot;&quot;驗證 E904&quot;&quot;&quot;
        return set(self.equipment_constraints) == set(current_constraints)
</code></pre>
<p><strong>錯誤碼定義（與 Interface Contract v1.1 對齊）</strong>：</p>
<pre><code class="language-python">class OptimizationError(Exception):
    ERROR_CODES = {
        # 原有錯誤碼（E801-E808）
        &quot;E801&quot;: &quot;MODEL_REGISTRY_ERROR - 無法載入 Model Registry Index 或模型檔案&quot;,
        &quot;E802&quot;: &quot;ANNOTATION_VERSION_MISMATCH - 模型訓練時的 Annotation checksum 與當前不符&quot;,
        &quot;E803&quot;: &quot;FEATURE_DIMENSION_MISMATCH - 特徵數量或名稱與模型預期不符&quot;,
        &quot;E804&quot;: &quot;TARGET_NOT_AVAILABLE - 請求的 target_id（如 system_total_kw）在 Registry 中不存在&quot;,
        &quot;E805&quot;: &quot;HYBRID_INCONSISTENCY - Component Models 加總與 System Model 預測差異 &gt;5%&quot;,
        &quot;E806&quot;: &quot;SYSTEM_MODEL_DISCREPANCY - 模型差異過大（Training-Optimization 銜接錯誤）&quot;,
        &quot;E807&quot;: &quot;RT_NOT_ACHIEVABLE - 無法達到目標冷凍噸（設備容量不足）&quot;,
        &quot;E808&quot;: &quot;EFFICIENCY_NOT_ACHIEVABLE - 無法達到目標 kW/RT&quot;,

        # v1.2 新增錯誤碼（與 Interface Contract v1.1 對齊）
        &quot;E809&quot;: &quot;OPTIMIZATION_INFEASIBLE - 所有降級層級均無法產生可行解&quot;,
        &quot;E810&quot;: &quot;CRITICAL_MODEL_MISMATCH - Hybrid 模式差異 &gt;15%，模型嚴重不一致&quot;,
        &quot;E811&quot;: &quot;RESOURCE_LIMIT_EXCEEDED - 記憶體或計算資源超限&quot;,
        &quot;E812&quot;: &quot;CONSTRAINT_VIOLATION_HARD - 違反硬約束且無法放寬&quot;,

        # 跨階段錯誤碼（Interface Contract v1.1）
        &quot;E901&quot;: &quot;FEATURE_ALIGNMENT_MISMATCH - 推論特徵順序/名稱與訓練時不一致&quot;,
        &quot;E902&quot;: &quot;FEATURE_DIMENSION_MISMATCH - 推論特徵維度與訓練時不同&quot;,
        &quot;E903&quot;: &quot;SCALER_MISMATCH - 縮放參數與特徵不匹配或缺失&quot;,
        &quot;E904&quot;: &quot;EQUIPMENT_CONSTRAINT_INCONSISTENT - 當前設備限制與訓練時不一致&quot;,
    }
</code></pre>
<h3 id="phase-1-day-2">Phase 1: 約束引擎與可行解空間 (Day 2)</h3>
<p><strong>Step 1.1: 物理限制載入與同步</strong><br />
- 從 <code>FeatureAnnotationManager</code> 讀取 <code>physical_types</code> 的 <code>valid_range</code><br />
- 與 Optimization Config 中的 <code>physical_constraints</code> 合併（Config 優先）<br />
- <strong>v1.2 新增</strong>：與 <code>EquipmentValidator</code> 建立同步機制，確保 Cleaner 與 Optimization 使用相同的設備邏輯</p>
<p><strong>Step 1.2: 邏輯約束引擎（含 v1.1 與 v1.2 新增）</strong><br />
- 實作 <code>LogicConstraintGraph</code>，支援 requires/mutex/sequence/min_runtime/min_downtime<br />
- <strong>v1.2 新增</strong>：約束分類（硬約束 vs 軟約束），支援 <code>relax_soft_constraints()</code><br />
- 實作 <code>get_feasible_combinations()</code>：枚舉所有滿足硬約束的設備啟停組合<br />
- <strong>v1.2 新增</strong>：記憶體安全檢查，設備數 &gt; 10 時自動切換為啟發式枚舉</p>
<p><strong>Step 1.3: 可行解預篩選（含暖啟動預留）</strong></p>
<pre><code class="language-python">def enumerate_feasible_combinations(
    target_rt: float, 
    site_config: OptimizationConfig,
    warm_start_hint: Optional[Dict] = None  # v1.2 新增：暖啟動提示
) -&gt; List[Dict]:
    &quot;&quot;&quot;
    給定目標 RT，找出所有可行的設備啟停組合
    v1.2 更新：
    - 支援暖啟動提示（優先評估與前次相似的組合）
    - 記憶體安全檢查（組合數上限）
    &quot;&quot;&quot;
    # 實作細節（略）
    pass
</code></pre>
<h3 id="phase-2-fallback-day-3-4">Phase 2: 最佳化核心與 Fallback 機制 (Day 3-4)</h3>
<p><strong>Step 2.1: 目標函數封裝（v1.2 更新：整合 Resource Monitor）</strong></p>
<pre><code class="language-python">class ObjectiveFunction:
    &quot;&quot;&quot;
    支援兩種模式的目标函数（v1.2 更新：整合切換懲罰與資源監控）
    &quot;&quot;&quot;

    def __init__(
        self, 
        mode: str, 
        target_value: float, 
        model_registry: ModelRegistry,
        constraint_engine: ConstraintEngine,
        vectorizer: FeatureVectorizer,
        resource_monitor: Optional[ResourceMonitor] = None  # v1.2 新增
    ):
        # 初始化（見前文）
        pass

    def evaluate(self, continuous_vars, discrete_vars, ambient) -&gt; float:
        &quot;&quot;&quot;
        回傳損失值（越小越好）
        v1.2 更新：
        - 使用 FeatureVectorizer 轉換特徵
        - 加入切換懲罰（switching_penalty）
        - 檢查資源使用（防止 OOM）
        &quot;&quot;&quot;
        # 檢查記憶體使用（v1.2 新增）
        if self.resource_monitor and self.resource_monitor.is_memory_critical():
            raise ResourceLimitError(&quot;E811: 記憶體使用超過安全閾值&quot;)

        # 原有評估邏輯（見 v1.1）
        pass
</code></pre>
<p><strong>Step 2.2: 混合優化策略（含 Fallback 整合）</strong></p>
<pre><code class="language-python">class HybridOptimizer:
    &quot;&quot;&quot;
    混合整數規劃 + 連續優化 + Fallback 機制（v1.2 更新）
    &quot;&quot;&quot;

    def __init__(
        self, 
        model_registry: ModelRegistry, 
        constraint_engine: ConstraintEngine,
        fallback_handler: FallbackHandler  # v1.2 新增
    ):
        self.model_registry = model_registry
        self.constraint_engine = constraint_engine
        self.fallback_handler = fallback_handler

    def optimize(self, request: OptimizationRequest) -&gt; OptimizationResponse:
        &quot;&quot;&quot;
        執行優化（含自動降級）
        &quot;&quot;&quot;
        # 使用 FallbackHandler 包裝實際優化邏輯
        result, fallback_status = self.fallback_handler.execute_with_fallback(
            self._do_optimize, request
        )

        # 建立回應（包含 Fallback 狀態）
        return self._build_response(result, request, fallback_status)

    def _do_optimize(self, request: OptimizationRequest) -&gt; OptimizationResult:
        &quot;&quot;&quot;
        實際優化邏輯（與 v1.1 類似，但增加中斷檢查點）
        &quot;&quot;&quot;
        # Phase 1：枚舉可行組合（支援暖啟動）
        feasible_combos = self.constraint_engine.get_feasible_combinations(
            request.target_rt,
            warm_start_hint=self._get_warm_start_hint(request)
        )

        # Phase 2：對每個組合優化連續變數（支援超時中斷）
        best_result = None
        for combo in feasible_combos:
            # 檢查是否收到中斷信號（v1.2 新增）
            if self._is_interrupted():
                break

            result = self._optimize_continuous(combo, request)
            # 更新最佳解...

        return best_result

    def _optimize_continuous(self, combo, request):
        &quot;&quot;&quot;
        對固定設備組合優化連續參數（支援部分解保留）
        &quot;&quot;&quot;
        from scipy.optimize import differential_evolution

        # 定義帶有超時檢查的回調函數（v1.2 新增）
        def callback(xk, convergence):
            if time.time() - start_time &gt; request.fallback_policy.timeout_seconds:
                raise OptimizationTimeoutError(&quot;迭代中超時&quot;)
            return False

        result = differential_evolution(
            objective, bounds, 
            max_iter=config.max_iter,
            callback=callback,  # v1.2 新增
            polish=True,
            seed=42
        )
        return result
</code></pre>
<h3 id="phase-3-day-4-5">Phase 3: 報告生成與進階分析 (Day 4-5)</h3>
<p><strong>Step 3.1: 改善前後比較邏輯（v1.2 更新：進階報告）</strong></p>
<pre><code class="language-python">class SavingsCalculator:
    &quot;&quot;&quot;
    計算節能量與改善評估（v1.2 更新：進階分析功能）
    &quot;&quot;&quot;

    def calculate(self, ...):
        &quot;&quot;&quot;
        基礎計算（與 v1.1 相同）
        &quot;&quot;&quot;
        pass

    def calculate_sensitivity_analysis(
        self,
        recommended: Dict,
        ambient: Dict,
        perturbations: Dict[str, Tuple[float, float]] = None
    ) -&gt; SensitivityReport:
        &quot;&quot;&quot;
        v1.2 新增：敏感性分析
        分析關鍵參數（如外氣溫度、負載率）擾動對結果的影響
        &quot;&quot;&quot;
        if perturbations is None:
            perturbations = {
                &quot;wet_bulb_temp&quot;: (-1.0, 1.0),  # ±1°C
                &quot;target_rt&quot;: (-0.1, 0.1)       # ±10%
            }

        # 執行擾動分析（略）
        pass

    def generate_pareto_frontier(
        self,
        request: OptimizationRequest,
        objectives: List[str] = [&quot;total_kw&quot;, &quot;equipment_wear&quot;]
    ) -&gt; List[Dict]:
        &quot;&quot;&quot;
        v1.2 新增：Pareto Frontier 生成（多目標優化）
        &quot;&quot;&quot;
        # 使用多目標優化算法（如 NSGA-II）或網格搜索
        pass
</code></pre>
<p><strong>Step 3.2: 報告生成器（v1.2 更新：決策支援深度）</strong></p>
<pre><code class="language-python">class OptimizationReportGenerator:
    &quot;&quot;&quot;
    生成工程師可讀的優化報告（v1.2 強化版）
    &quot;&quot;&quot;

    def generate(self, response: OptimizationResponse, request: OptimizationRequest) -&gt; str:
        &quot;&quot;&quot;
        依據 report_depth 產生不同深度報告：
        - basic: 建議配置、預測能耗、Fallback 狀態
        - standard: 增加節能評估、Hybrid 檢查、約束狀態
        - advanced: 增加敏感性分析、Pareto Frontier、What-if 比較
        &quot;&quot;&quot;
        if request.report_depth == &quot;basic&quot;:
            return self._generate_basic_report(response)
        elif request.report_depth == &quot;standard&quot;:
            return self._generate_standard_report(response)
        else:  # advanced
            return self._generate_advanced_report(response)

    def _generate_advanced_report(self, response: OptimizationResponse) -&gt; str:
        &quot;&quot;&quot;
        進階報告包含：
        1. 建議配置與 Fallback 狀態
        2. 敏感性分析：關鍵參數擾動影響
        3. Pareto Frontier：節能 vs 設備磨耗權衡
        4. What-if 情境：當前 vs 建議 vs 極限配置
        5. 診斷資訊：求解器收斂過程、約束鬆緊度
        &quot;&quot;&quot;
        report = f&quot;&quot;&quot;
# 冰水主機房最佳化建議報告（進階版）

## 1. 執行摘要
- 案場 ID：{response.site_id}
- Fallback 狀態：{response.fallback_status}
- 建議品質：{response.fallback_status.solution_quality if response.fallback_status else 'optimal'}

## 2. 最佳化結果與情境比較
### 2.1 三軌比較（What-if Analysis）
| 指標 | 當前配置 | 建議配置 | 極限配置（全開） | 節省率 |
|------|----------|----------|------------------|--------|
| 總耗電 (kW) | {baseline} | {recommended} | {max_capacity} | {savings}% |
| 效率 (kW/RT) | {baseline_eff} | {recommended_eff} | {max_eff} | - |
| 設備磨耗指數 | {baseline_wear} | {recommended_wear} | {max_wear} | - |

## 3. 敏感性分析（Sensitivity Analysis）
### 3.1 外氣濕球溫度影響
- 濕球溫度 +1°C：最佳 kW/RT 上升 {sensitivity['wb_temp+1']:.2f}
- 濕球溫度 -1°C：最佳 kW/RT 下降 {sensitivity['wb_temp-1']:.2f}

### 3.2 負載率影響
- 負載 -10%：建議開機數可能減少至 {sensitivity['load-10']['chiller_count']}
- 負載 +10%：建議開機數可能增加至 {sensitivity['load+10']['chiller_count']}

## 4. Pareto 前沿分析（多目標權衡）
顯示「總耗電」與「設備磨耗」的最佳權衡曲線，標記當前建議在前沿上的位置。

## 5. 診斷與除錯資訊
- 求解器迭代次數：{response.solver_metadata.iterations}
- 目標函數評估次數：{response.solver_metadata.objective_evaluations}
- 收斂狀態：{response.solver_metadata.convergence_status}
- 起作用約束：{response.binding_constraints}
&quot;&quot;&quot;
        return report
</code></pre>
<h3 id="phase-4-fallback-day-5-6v12-phase">Phase 4: Fallback 機制與資源管理 (Day 5-6)（v1.2 新增 Phase）</h3>
<p><strong>Step 4.1: Fallback Handler 實作</strong><br />
- 實作三級降級邏輯（Level 1-3）<br />
- 整合 <code>InfeasibilityAnalyzer</code> 產生診斷報告<br />
- 實作 <code>GreedyHeuristicOptimizer</code> 作為 Level 2 備援</p>
<p><strong>Step 4.2: 資源管理與暖啟動</strong></p>
<pre><code class="language-python">class ResourceMonitor:
    &quot;&quot;&quot;
    資源監控器（v1.2 新增）
    &quot;&quot;&quot;

    def __init__(self, max_memory_gb: float = 4.0):
        self.max_memory = max_memory_gb * 1024 * 1024 * 1024  # 轉為 bytes
        self.process = psutil.Process()

    def is_memory_critical(self) -&gt; bool:
        &quot;&quot;&quot;檢查是否接近記憶體上限&quot;&quot;&quot;
        current_mem = self.process.memory_info().rss
        return current_mem &gt; self.max_memory * 0.9

    def estimate_combination_memory(self, n_devices: int) -&gt; float:
        &quot;&quot;&quot;
        預估枚舉設備組合所需記憶體
        公式：2^n * 平均配置大小 * 安全係數
        &quot;&quot;&quot;
        estimated = (2 ** n_devices) * 1024 * 1.5  # 簡化估算
        return estimated

class WarmStartManager:
    &quot;&quot;&quot;
    暖啟動管理器（v1.2 新增）
    批次優化時，將上一個 RT 目標的解作為下一個的初始提示
    &quot;&quot;&quot;

    def __init__(self):
        self.previous_solution = None

    def save_solution(self, solution: Dict, target_rt: float):
        &quot;&quot;&quot;儲存當前解供下次使用&quot;&quot;&quot;
        self.previous_solution = {
            'config': solution,
            'target_rt': target_rt,
            'timestamp': datetime.now()
        }

    def get_hint(self, new_target_rt: float) -&gt; Optional[Dict]:
        &quot;&quot;&quot;
        取得暖啟動提示
        策略：若新目標與前次相差 &lt; 20%，使用前次解作為初始種群
        &quot;&quot;&quot;
        if not self.previous_solution:
            return None

        prev_rt = self.previous_solution['target_rt']
        if abs(new_target_rt - prev_rt) / prev_rt &lt; 0.2:
            return self.previous_solution['config']
        return None
</code></pre>
<h3 id="phase-5-cli-day-6-7">Phase 5: CLI 與多案場支援 (Day 6-7)</h3>
<p><strong>Step 5.1: OptimizationCLI（v1.2 更新：Fallback 控制）</strong></p>
<pre><code class="language-python">class OptimizationCLI:
    &quot;&quot;&quot;
    命令列介面（v1.2 更新：支援 Fallback 與進階報告）
    &quot;&quot;&quot;

    def optimize(
        self, 
        site: str, 
        mode: str, 
        target: float,
        fallback_level: int = 3,           # v1.2 新增：最大降級層級
        timeout: int = 300,                # v1.2 新增：超時時間
        report_depth: str = &quot;standard&quot;,    # v1.2 新增：報告深度
        warm_start: bool = True,           # v1.2 新增：啟用暖啟動
        # ... 其他參數
    ):
        &quot;&quot;&quot;
        CLI 指令範例：

        # 標準使用（啟用自動降級）
        python main.py optimization optimize \
            --site cgmh_ty \
            --mode load_driven \
            --target 500 \
            --fallback-level 3 \
            --timeout 300 \
            --report-depth advanced \
            --warm-start \
            --output report.md
        &quot;&quot;&quot;
        pass
</code></pre>
<hr />
<h2 id="5-error-codes-v12">5. 錯誤代碼對照表 (Error Codes) - v1.2 完整版</h2>
<p>與 Model Training v1.2 及 Interface Contract v1.1 對齊的錯誤碼體系：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">錯誤代碼</th>
<th style="text-align: left;">名稱</th>
<th style="text-align: center;">發生階段</th>
<th style="text-align: left;">說明</th>
<th style="text-align: left;">處理建議</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>E800</strong></td>
<td style="text-align: left;"><code>CONFIG_VALIDATION_ERROR</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">Optimization Config YAML 格式錯誤</td>
<td style="text-align: left;">檢查 config/optimization/sites/{site}.yaml</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E801</strong></td>
<td style="text-align: left;"><code>MODEL_REGISTRY_NOT_FOUND</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">找不到 model_registry_index.json 或模型檔案</td>
<td style="text-align: left;">確認模型訓練已完成（Training v1.2+）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E802</strong></td>
<td style="text-align: left;"><code>ANNOTATION_CHECKSUM_MISMATCH</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">模型訓練時的 Annotation checksum 與當前不符</td>
<td style="text-align: left;">Feature Annotation 已更新，需重新訓練模型</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E803</strong></td>
<td style="text-align: left;"><code>FEATURE_DIMENSION_MISMATCH</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">Optimization Config 特徵數與 ModelEntry.feature_count 不符</td>
<td style="text-align: left;">檢查 feature_mapping 設定或重新訓練模型</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E804</strong></td>
<td style="text-align: left;"><code>TARGET_NOT_AVAILABLE</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">請求的 target_id（如 system_total_kw）在 Registry 中不存在</td>
<td style="text-align: left;">確認 Training Pipeline 已訓練該 target</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E805</strong></td>
<td style="text-align: left;"><code>HYBRID_INCONSISTENCY</code></td>
<td style="text-align: center;">Phase 2</td>
<td style="text-align: left;">Component Models 加總與 System Model 預測差異 &gt;5%</td>
<td style="text-align: left;">警告：檢查特徵工程或改用純 System-Level</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E806</strong></td>
<td style="text-align: left;"><code>OPTIMIZATION_TIMEOUT</code></td>
<td style="text-align: center;">Phase 2</td>
<td style="text-align: left;">優化算法超時未收斂</td>
<td style="text-align: left;">啟用 Fallback Level 1-2，或增加 timeout</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E807</strong></td>
<td style="text-align: left;"><code>RT_NOT_ACHIEVABLE</code></td>
<td style="text-align: center;">Phase 2</td>
<td style="text-align: left;">無法達到目標冷凍噸（設備容量不足）</td>
<td style="text-align: left;">檢查目標 RT 是否超過總裝置容量，啟用備用機組</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E808</strong></td>
<td style="text-align: left;"><code>EFFICIENCY_NOT_ACHIEVABLE</code></td>
<td style="text-align: center;">Phase 2</td>
<td style="text-align: left;">無法達到目標 kW/RT（可能過於激進）</td>
<td style="text-align: left;">檢查目標效率是否低於理論最小值</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E809</strong></td>
<td style="text-align: left;"><code>OPTIMIZATION_INFEASIBLE</code></td>
<td style="text-align: center;">Phase 4</td>
<td style="text-align: left;">所有降級層級均無法產生可行解</td>
<td style="text-align: left;">回傳當前配置（Fallback Level 3），產生診斷報告</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E810</strong></td>
<td style="text-align: left;"><code>CRITICAL_MODEL_MISMATCH</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">Hybrid 模式下 Component 與 System 預測差異 &gt;15%</td>
<td style="text-align: left;">強制終止，要求重新訓練模型（資料或特徵工程可能有誤）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E811</strong></td>
<td style="text-align: left;"><code>RESOURCE_LIMIT_EXCEEDED</code></td>
<td style="text-align: center;">Phase 2</td>
<td style="text-align: left;">記憶體或計算資源超限</td>
<td style="text-align: left;">啟用啟發式算法（Fallback Level 2）或增加資源</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E812</strong></td>
<td style="text-align: left;"><code>CONSTRAINT_VIOLATION_HARD</code></td>
<td style="text-align: center;">Phase 1</td>
<td style="text-align: left;">違反硬約束且無法放寬</td>
<td style="text-align: left;">檢查設備邏輯設定或啟用 Fallback 放寬軟約束</td>
</tr>
<tr>
<td style="text-align: left;"><strong>W801</strong></td>
<td style="text-align: left;"><code>SOFT_CONSTRAINT_VIOLATED</code></td>
<td style="text-align: center;">Phase 2</td>
<td style="text-align: left;">違反軟約束（如建議開啟備用機組）</td>
<td style="text-align: left;">建議接受，但記錄偏好衝突</td>
</tr>
<tr>
<td style="text-align: left;"><strong>W802</strong></td>
<td style="text-align: left;"><code>FALLBACK_TRIGGERED</code></td>
<td style="text-align: center;">Phase 4</td>
<td style="text-align: left;">已觸發降級機制（非錯誤，僅提醒）</td>
<td style="text-align: left;">檢查報告中的 fallback_status 了解詳情</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E901</strong></td>
<td style="text-align: left;"><code>FEATURE_ALIGNMENT_MISMATCH</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">推論特徵順序/名稱與訓練時不一致（Interface Contract）</td>
<td style="text-align: left;">檢查 ETL 流程，確認特徵產生邏輯（絕不可自動恢復）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E902</strong></td>
<td style="text-align: left;"><code>FEATURE_DIMENSION_MISMATCH</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">推論特徵維度與訓練時不同</td>
<td style="text-align: left;">確認特徵工程邏輯變更</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E903</strong></td>
<td style="text-align: left;"><code>SCALER_MISMATCH</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">縮放參數與特徵不匹配或缺失</td>
<td style="text-align: left;">使用線上統計即時計算（標記警告）或重新訓練</td>
</tr>
<tr>
<td style="text-align: left;"><strong>E904</strong></td>
<td style="text-align: left;"><code>EQUIPMENT_CONSTRAINT_INCONSISTENT</code></td>
<td style="text-align: center;">Phase 0</td>
<td style="text-align: left;">當前設備限制與訓練時不一致</td>
<td style="text-align: left;">檢查設備配置變更是否影響模型有效性（警告或拒絕）</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="6-version-compatibility-v12">6. 版本相容性矩陣 (Version Compatibility) - v1.2 更新</h2>
<table>
<thead>
<tr>
<th style="text-align: center;">Model Training</th>
<th style="text-align: center;">Feature Annotation</th>
<th style="text-align: center;">Interface Contract</th>
<th style="text-align: center;">Optimization Engine</th>
<th style="text-align: center;">相容性</th>
<th style="text-align: left;">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>v1.2</strong></td>
<td style="text-align: center;">v1.2</td>
<td style="text-align: center;"><strong>v1.1</strong></td>
<td style="text-align: center;"><strong>v1.2</strong></td>
<td style="text-align: center;">✅ <strong>完全相容</strong></td>
<td style="text-align: left;">推薦配置，支援 Fallback、暖啟動、特徵對齊 E901-E904</td>
</tr>
<tr>
<td style="text-align: center;">v1.2</td>
<td style="text-align: center;">v1.2</td>
<td style="text-align: center;">v1.0</td>
<td style="text-align: center;">v1.2</td>
<td style="text-align: center;">⚠️ <strong>部分相容</strong></td>
<td style="text-align: left;">缺少特徵嚴格對齊檢查，存在 Silent Failure 風險</td>
</tr>
<tr>
<td style="text-align: center;">v1.2</td>
<td style="text-align: center;">v1.2</td>
<td style="text-align: center;">v1.1</td>
<td style="text-align: center;">v1.1</td>
<td style="text-align: center;">⚠️ <strong>部分相容</strong></td>
<td style="text-align: left;">缺少 Fallback 機制與進階報告，但核心功能正常</td>
</tr>
<tr>
<td style="text-align: center;">v1.1</td>
<td style="text-align: center;">任意</td>
<td style="text-align: center;">任意</td>
<td style="text-align: center;"><strong>v1.2</strong></td>
<td style="text-align: center;">❌ <strong>不相容</strong></td>
<td style="text-align: left;">缺少 feature_order_manifest，觸發 E901</td>
</tr>
<tr>
<td style="text-align: center;">v1.2</td>
<td style="text-align: center;">v1.2</td>
<td style="text-align: center;"><strong>v1.1</strong></td>
<td style="text-align: center;">v1.0</td>
<td style="text-align: center;">❌ <strong>不相容</strong></td>
<td style="text-align: left;">v1.0 無法解析 Interface Contract v1.1 的新檢查點</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="7-test-plan-v12">7. 測試與驗證計畫 (Test Plan) - v1.2 更新</h2>
<h3 id="71-fallback">7.1 單元測試（新增 Fallback 與資源管理測試）</h3>
<table>
<thead>
<tr>
<th style="text-align: left;">測試案例 ID</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">輸入</th>
<th style="text-align: left;">預期結果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">OPT-001</td>
<td style="text-align: left;">邏輯約束驗證</td>
<td style="text-align: left;">chiller_1_on=True, chw_pump_1_on=False</td>
<td style="text-align: left;">違反 requires 約束，回傳 False</td>
</tr>
<tr>
<td style="text-align: left;">OPT-002</td>
<td style="text-align: left;">可行組合枚舉</td>
<td style="text-align: left;">target_rt=500, 2台主機各300RT</td>
<td style="text-align: left;">回傳可行組合列表</td>
</tr>
<tr>
<td style="text-align: left;">OPT-003</td>
<td style="text-align: left;">負載驅動優化</td>
<td style="text-align: left;">target_rt=400, ambient=30°C</td>
<td style="text-align: left;">選擇效率最佳的設備組合與頻率</td>
</tr>
<tr>
<td style="text-align: left;"><strong>OPT-011</strong></td>
<td style="text-align: left;"><strong>Fallback Level 1</strong></td>
<td style="text-align: left;">存在軟約束衝突</td>
<td style="text-align: left;">放寬軟約束後成功求解，標記 W802</td>
</tr>
<tr>
<td style="text-align: left;"><strong>OPT-012</strong></td>
<td style="text-align: left;"><strong>Fallback Level 2</strong></td>
<td style="text-align: left;">數學規劃超時</td>
<td style="text-align: left;">切換至 Greedy Heuristic，產生可行解</td>
</tr>
<tr>
<td style="text-align: left;"><strong>OPT-013</strong></td>
<td style="text-align: left;"><strong>Fallback Level 3</strong></td>
<td style="text-align: left;">所有方法均失敗</td>
<td style="text-align: left;">回傳當前配置，標記 E809，附診斷報告</td>
</tr>
<tr>
<td style="text-align: left;"><strong>OPT-014</strong></td>
<td style="text-align: left;"><strong>資源限制</strong></td>
<td style="text-align: left;">記憶體限制 1GB，設備數 15</td>
<td style="text-align: left;">自動切換啟發式枚舉，無 OOM</td>
</tr>
<tr>
<td style="text-align: left;"><strong>OPT-015</strong></td>
<td style="text-align: left;"><strong>暖啟動</strong></td>
<td style="text-align: left;">連續優化 RT=400 → RT=420</td>
<td style="text-align: left;">第二次優化迭代次數減少 &gt;30%</td>
</tr>
<tr>
<td style="text-align: left;"><strong>OPT-016</strong></td>
<td style="text-align: left;"><strong>特徵對齊 E901</strong></td>
<td style="text-align: left;">故意打亂特徵順序</td>
<td style="text-align: left;">正確拋出 E901，拒絕執行</td>
</tr>
<tr>
<td style="text-align: left;"><strong>OPT-017</strong></td>
<td style="text-align: left;"><strong>設備限制一致性 E904</strong></td>
<td style="text-align: left;">訓練時有 min_runtime，當前移除</td>
<td style="text-align: left;">正確拋出 E904 警告</td>
</tr>
</tbody>
</table>
<h3 id="72-fallback-e2e">7.2 整合測試（新增 Fallback E2E 測試）</h3>
<table>
<thead>
<tr>
<th style="text-align: left;">測試案例 ID</th>
<th style="text-align: left;">描述</th>
<th style="text-align: left;">驗證目標</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">INT-OPT-001</td>
<td style="text-align: left;">端到端優化流程</td>
<td style="text-align: left;">從 Request 到 Report 完整流程，使用 Registry Index</td>
</tr>
<tr>
<td style="text-align: left;">INT-OPT-002</td>
<td style="text-align: left;">多案場切換</td>
<td style="text-align: left;">切換 cgmh_ty 與 farglory_o3，Config 與 Model 正確載入</td>
</tr>
<tr>
<td style="text-align: left;"><strong>INT-OPT-007</strong></td>
<td style="text-align: left;"><strong>Fallback E2E</strong></td>
<td style="text-align: left;">模擬求解失敗 → Level 1 → Level 2 → 成功產出報告</td>
</tr>
<tr>
<td style="text-align: left;"><strong>INT-OPT-008</strong></td>
<td style="text-align: left;"><strong>Timeout 處理</strong></td>
<td style="text-align: left;">設定 timeout=10s，驗證部分解保留與正確中斷</td>
</tr>
<tr>
<td style="text-align: left;"><strong>INT-OPT-009</strong></td>
<td style="text-align: left;"><strong>進階報告生成</strong></td>
<td style="text-align: left;">驗證敏感性分析、Pareto Frontier、What-if 比較正確產出</td>
</tr>
<tr>
<td style="text-align: left;"><strong>INT-OPT-010</strong></td>
<td style="text-align: left;"><strong>Interface Contract 對齊</strong></td>
<td style="text-align: left;">驗證與 Parser/Cleaner 的時間基準、設備邏輯同步</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="8-deliverables-v12">8. 交付物清單 (Deliverables) - v1.2 更新</h2>
<h3 id="81">8.1 程式碼檔案</h3>
<ol>
<li><code>src/optimization/engine.py</code> - 最佳化主引擎（更新：整合 Fallback Handler）</li>
<li><code>src/optimization/constraints.py</code> - 約束引擎（更新：軟硬約束分類、放寬機制）</li>
<li><code>src/optimization/scenarios.py</code> - 情境分析與批次處理（更新：暖啟動整合）</li>
<li><code>src/optimization/model_interface.py</code> - ModelRegistry 與 FeatureVectorizer（更新：E901-E904 驗證）</li>
<li><code>src/optimization/fallback.py</code> - <strong>新增：Fallback Handler、Greedy Heuristic、Infeasibility Analyzer</strong></li>
<li><code>src/optimization/resource_monitor.py</code> - <strong>新增：ResourceMonitor、WarmStartManager</strong></li>
<li><code>src/optimization/report.py</code> - 報告生成器（更新：進階報告功能）</li>
<li><code>src/optimization/config.py</code> - OptimizationConfig（更新：fallback_policy、resource_limits）</li>
</ol>
<h3 id="82">8.2 配置文件</h3>
<ol start="9">
<li><code>config/optimization/base.yaml</code> - 基礎設備模型與約束（更新：增加 fallback 設定）</li>
<li><code>config/optimization/sites/cgmh_ty.yaml</code> - 長庚醫院範例（更新格式 v1.2）</li>
<li><code>config/optimization/schemas/optimization_schema.json</code> - JSON Schema（更新：fallback_policy 驗證）</li>
</ol>
<h3 id="83">8.3 測試檔案</h3>
<ol start="12">
<li><code>tests/test_optimization_engine.py</code> - 引擎單元測試（更新）</li>
<li><code>tests/test_constraints.py</code> - 約束引擎測試（更新）</li>
<li><code>tests/test_fallback.py</code> - <strong>新增：Fallback 機制測試（含三級降級）</strong></li>
<li><code>tests/test_resource_monitor.py</code> - <strong>新增：資源管理與暖啟動測試</strong></li>
<li><code>tests/test_feature_alignment.py</code> - <strong>新增：E901-E904 特徵對齊測試</strong></li>
<li><code>tests/test_optimization_integration.py</code> - 整合測試（更新）</li>
</ol>
<h3 id="84">8.4 文件檔案</h3>
<ol start="18">
<li><code>docs/optimization/PRD_OPTIMIZATION_ENGINE_v1.2.md</code> - 本文件</li>
<li><code>docs/optimization/USER_GUIDE.md</code> - 工程師使用手冊（更新：Fallback 機制說明、進階報告解讀）</li>
<li><code>docs/optimization/MIGRATION_v1.1_to_v1.2.md</code> - <strong>新增：v1.1 升級指南（Fallback 整合步驟）</strong></li>
<li><code>docs/optimization/FALLBACK_PLAYBOOK.md</code> - <strong>新增：Fallback 機制運維手冊（含故障排除流程圖）</strong></li>
</ol>
<hr />
<h2 id="9-sign-off-checklist-v12">9. 驗收簽核 (Sign-off Checklist) - v1.2 更新</h2>
<h3 id="91-v11">9.1 基礎功能（與 v1.1 相容）</h3>
<ul>
<li>[ ] <strong>Registry 載入</strong>：正確從 <code>model_registry_index.json</code> 載入模型，驗證 E801</li>
<li>[ ] <strong>版本綁定</strong>：驗證 <code>annotation_checksum</code>，正確拋出 E802</li>
<li>[ ] <strong>系統級優化</strong>：預設使用 <code>system_total_kw</code> 進行優化（黑盒模式）</li>
<li>[ ] <strong>負載驅動模式</strong>：給定 RT=500，輸出最佳設備組合（台數、頻率、轉速）</li>
<li>[ ] <strong>效率驅動模式</strong>：給定 kW/RT=0.65，反推設備參數，達成目標效率</li>
<li>[ ] <strong>節能評估</strong>：正確計算改善前後差異、年節電量、減碳量</li>
</ul>
<h3 id="92-v12-fallback">9.2 v1.2 新增：Fallback 機制（核心驗收項目）</h3>
<ul>
<li>[ ] <strong>Fallback Level 1</strong>：當存在軟約束衝突時，自動放寬並重新求解，標記 W802</li>
<li>[ ] <strong>Fallback Level 2</strong>：當數學規劃超時（模擬 10s timeout），自動切換至 Greedy Heuristic 產生可行解</li>
<li>[ ] <strong>Fallback Level 3</strong>：當所有方法均失敗，回傳當前配置並標記 E809，附帶詳細診斷報告（說明為何無法優化）</li>
<li>[ ] <strong>Infeasibility 診斷</strong>：當目標 RT 超過總容量時，診斷報告明確指出「建議啟用備用機組或降低負載至 X RT」</li>
<li>[ ] <strong>超時中斷</strong>：長時間優化（&gt;300s）可透過 signal 中斷，並回傳「目前為止找到的最佳解」（部分解保留）</li>
</ul>
<h3 id="93-v12-interface-contract">9.3 v1.2 新增：Interface Contract 對齊</h3>
<ul>
<li>[ ] <strong>特徵對齊 E901</strong>：故意打亂特徵順序時，系統正確拋出 E901 並終止（不可自動恢復）</li>
<li>[ ] <strong>縮放參數驗證 E903</strong>：驗證 StandardScaler 參數正確載入與應用</li>
<li>[ ] <strong>設備限制一致性 E904</strong>：當 Optimization Config 與 Training 時的設備限制不一致，正確拋出警告或錯誤</li>
<li>[ ] <strong>時間基準隔離</strong>：Optimization 產生新的 <code>pipeline_origin_timestamp</code>，與 Training 時間戳區隔</li>
</ul>
<h3 id="94-v12">9.4 v1.2 新增：資源管理與效能</h3>
<ul>
<li>[ ] <strong>記憶體預估</strong>：設備數 &gt; 10 時，自動切換為啟發式枚舉，防止 OOM</li>
<li>[ ] <strong>暖啟動</strong>：批次優化 RT=400 → 420 時，第二次優化迭代次數較第一次減少 &gt;30%</li>
<li>[ ] <strong>平行評估</strong>：枚舉可行組合時，支援平行評估各組合的連續變數優化（8 核心利用率 &gt;70%）</li>
</ul>
<h3 id="95-v12">9.5 v1.2 新增：進階報告</h3>
<ul>
<li>[ ] <strong>敏感性分析</strong>：報告包含外氣溫度 ±1°C、負載 ±10% 對最佳 kW/RT 的影響範圍</li>
<li>[ ] <strong>Pareto Frontier</strong>：多目標優化（節能 vs 設備磨耗）時，顯示非支配解前沿曲線</li>
<li>[ ] <strong>What-if 比較</strong>：報告包含「當前配置 vs 建議配置 vs 極限配置」三軌比較表</li>
<li>[ ] <strong>Fallback 狀態追蹤</strong>：報告明確標示是否觸發降級、使用哪一層級、原始錯誤為何</li>
</ul>
<hr />
<h2 id="10-fallback">10. 附錄：Fallback 機制決策流程圖</h2>
<pre><code>開始優化請求
    │
    ▼
┌─────────────────┐
│ 載入 Model Registry │◄─── 失敗 ───► E801/E802/E901 終止
│ 驗證特徵對齊 E901   │
└─────────────────┘
    │
    ▼
┌─────────────────┐
│ Level 0: 標準優化  │
│ (完整約束 + DE)   │
└─────────────────┘
    │
    ├── 成功 ───► 產出最佳解，標記 fallback_level=0
    │
    ├── 失敗（Infeasible）──┐
    │                       ▼
    │           ┌─────────────────┐
    │           │ Level 1: 放寬軟約束 │
    │           │ (移除偏好、放寬互斥) │
    │           └─────────────────┘
    │                       │
    │           ┌───────────┴───────────┐
    │           ▼                       ▼
    │       成功（可行解）            失敗
    │           │                       │
    │           ▼                       ▼
    │   標記 fallback_level=1   ┌─────────────────┐
    │   警告 W802                │ Level 2: 啟發式   │
    │                            │ (Greedy + 局部搜索)│
    │                            └─────────────────┘
    │                                       │
    │                           ┌───────────┴───────────┐
    │                           ▼                       ▼
    │                       成功（可行解）            失敗
    │                           │                       │
    │                           ▼                       ▼
    │                   標記 fallback_level=2   ┌─────────────────┐
    │                   警告 W802                │ Level 3: 回退當前 │
    │                                            │ (維持現狀 + 診斷) │
    │                                            └─────────────────┘
    │                                                       │
    └───────────────────────────────────────────────────────┘
                                                            │
                                                            ▼
                                                    標記 fallback_level=3
                                                    錯誤 E809（附診斷報告）
                                                    回傳當前配置
</code></pre>
<hr />
<h2 id="11-fallback">11. 附錄：使用範例（含 Fallback 情境）</h2>
<h3 id="1-fallback">範例 1：標準優化（未觸發 Fallback）</h3>
<pre><code class="language-bash">python main.py optimization optimize \
    --site cgmh_ty \
    --mode load_driven \
    --target 500 \
    --report-depth standard \
    --output report_500rt.md
</code></pre>
<p><strong>預期輸出</strong>：</p>
<pre><code>模型資訊：使用 xgboost (20260214_120000)
Fallback 狀態：未觸發 (Level 0)
建議開啟：Chiller 1 (Primary, 300RT) + Chiller 2 (Backup, 200RT)
載率分配：60% / 40%
預測總耗電：325 kW (0.65 kW/RT)
節省率：相較於基線 18.75%，年節電 657,000 kWh
</code></pre>
<h3 id="2-fallback-level-2">範例 2：觸發 Fallback Level 2（啟發式算法）</h3>
<pre><code class="language-bash">python main.py optimization optimize \
    --site cgmh_ty \
    --mode load_driven \
    --target 800 \
    --timeout 30 \
    --fallback-level 3 \
    --report-depth advanced \
    --output report_fallback.md
</code></pre>
<p><strong>情境</strong>：目標 800 RT 接近系統極限，標準優化在 30 秒內無法收斂。</p>
<p><strong>預期輸出</strong>：</p>
<pre><code>⚠️ Fallback 觸發警告 (W802)

原始錯誤：優化超時 (E806)
降級層級：Level 2 (Greedy Heuristic)
解品質：可行但非全域最佳 (Feasible)

建議配置：
- 開啟所有主機（3台）以滿足 800 RT 需求
- 載率分配：90% / 85% / 75%（依效率排序）
- 預測總耗電：585 kW (0.73 kW/RT)

診斷資訊：
- 系統總容量：850 RT，目標 800 RT 已達 94% 負載
- 建議：考慮啟用備用冷卻水塔以提升效率
- 敏感性：外氣溫度每上升 1°C，效率預計惡化 3.2%

Pareto Frontier：
[顯示能耗 vs 設備磨耗的權衡曲線，標記當前建議位置]
</code></pre>
<h3 id="3fallback-level-3">範例 3：完全不可行（Fallback Level 3）</h3>
<pre><code class="language-bash">python main.py optimization optimize \
    --site cgmh_ty \
    --mode load_driven \
    --target 1200 \
    --current-config current_op.json \
    --output report_infeasible.md
</code></pre>
<p><strong>情境</strong>：目標 1200 RT 超過系統總容量 900 RT。</p>
<p><strong>預期輸出</strong>：</p>
<pre><code>❌ 優化不可行錯誤 (E809)

降級層級：Level 3 (回退當前配置)
回傳策略：維持當前運行參數

診斷報告：
1. 容量不足：目標 1200 RT 超過系統總裝置容量 900 RT（3台主機各 300RT）
2. 建議方案：
   - 短期：降低負載需求至 900 RT 以下，或啟用緊急製冷設備
   - 長期：增設 Chiller_4（建議容量 300RT）以滿足尖峰需求
3. 當前配置評估：維持現狀，預測能耗 720 kW，效率 0.80 kW/RT

約束衝突詳情：
- Hard Constraint Violated: max_system_capacity (900 RT &lt; 1200 RT)
- 無法透過放寬軟約束解決
</code></pre>
<hr />
<p><strong>關鍵設計確認 (v1.2)</strong>:<br />
1. <strong>強健性 Fallback</strong>：三級降級機制確保工程師始終獲得可行建議，而非系統錯誤<br />
2. <strong>資源感知</strong>：記憶體預估與暖啟動機制，支援大規模批次優化<br />
3. <strong>Interface Contract 對齊</strong>：嚴格特徵對齊（E901-E904）與時間基準隔離，防止 Silent Failure<br />
4. <strong>決策支援深度</strong>：敏感性分析、Pareto Frontier、What-if 比較，提升工程師採用率<br />
5. <strong>物理邏輯一致性</strong>：與 Data Cleaner 的設備驗證同步，確保「清洗-訓練-優化」邏輯閉環<br />
```</p>
</body>
</html>